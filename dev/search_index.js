var documenterSearchIndex = {"docs":
[{"location":"user_interface/matrix_functions/#Matrix-functions","page":"Matrix functions","title":"Matrix functions","text":"","category":"section"},{"location":"user_interface/matrix_functions/","page":"Matrix functions","title":"Matrix functions","text":"Coming soon...","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"CurrentModule = MatrixAlgebraKit\nCollapsedDocStrings = true","category":"page"},{"location":"library/#Library-documentation","page":"Library","title":"Library documentation","text":"","category":"section"},{"location":"library/#Constants-and-types","page":"Library","title":"Constants and types","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [MatrixAlgebraKit]\nOrder   = [:constant, :type]","category":"page"},{"location":"library/#MatrixAlgebraKit.AbstractAlgorithm","page":"Library","title":"MatrixAlgebraKit.AbstractAlgorithm","text":"abstract type AbstractAlgorithm end\n\nSupertype to dispatch on specific implementations of different the different functions. Concrete subtypes should represent both a way to dispatch to a given implementation, as well as the configuration of that implementation.\n\nSee also select_algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.Algorithm","page":"Library","title":"MatrixAlgebraKit.Algorithm","text":"Algorithm{name,KW} <: AbstractAlgorithm\n\nBare-bones implementation of an algorithm, where name should be a Symbol to dispatch on, and KW is typically a NamedTuple indicating the keyword arguments.\n\nSee also @algdef.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.LAPACK_Bisection","page":"Library","title":"MatrixAlgebraKit.LAPACK_Bisection","text":"LAPACK_Bisection()\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Bisection algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.LAPACK_DivideAndConquer","page":"Library","title":"MatrixAlgebraKit.LAPACK_DivideAndConquer","text":"LAPACK_DivideAndConquer()\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Divide and Conquer algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.LAPACK_Expert","page":"Library","title":"MatrixAlgebraKit.LAPACK_Expert","text":"LAPACK_Expert()\n\nAlgorithm type to denote the expert LAPACK driver for computing the Schur or non-Hermitian eigenvalue decomposition of a matrix.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.LAPACK_HouseholderLQ","page":"Library","title":"MatrixAlgebraKit.LAPACK_HouseholderLQ","text":"LAPACK_HoudeholderLQ(; blocksize, positive = false)\n\nAlgorithm type to denote the standard LAPACK algorithm for computing the LQ decomposition of a matrix using Householder reflectors. The specific LAPACK function can be controlled using the keyword arugments, i.e. ?gelqt will be chosen if blocksize > 1 or ?gelqf will be chosen if blocksize == 1. The keyword positive=true can be used to ensure that the diagonal elements of L are non-negative.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.LAPACK_HouseholderQR","page":"Library","title":"MatrixAlgebraKit.LAPACK_HouseholderQR","text":"LAPACK_HoudeholderQR(; blocksize, positive = false, pivoted = false)\n\nAlgorithm type to denote the standard LAPACK algorithm for computing the QR decomposition of a matrix using Householder reflectors. The specific LAPACK function can be controlled using the keyword arugments, i.e.  ?geqrt will be chosen if blocksize > 1. With blocksize == 1, ?geqrf will be chosen if pivoted == false and ?geqp3 will be chosen if pivoted == true. The keyword positive =true can be used to ensure that the diagonal elements of R are non-negative.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.LAPACK_Jacobi","page":"Library","title":"MatrixAlgebraKit.LAPACK_Jacobi","text":"LAPACK_Jacobi()\n\nAlgorithm type to denote the LAPACK driver for computing the singular value decomposition of a general matrix using the Jacobi algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.LAPACK_MultipleRelativelyRobustRepresentations","page":"Library","title":"MatrixAlgebraKit.LAPACK_MultipleRelativelyRobustRepresentations","text":"LAPACK_MultipleRelativelyRobustRepresentations()\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix using the Multiple Relatively Robust Representations algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.LAPACK_QRIteration","page":"Library","title":"MatrixAlgebraKit.LAPACK_QRIteration","text":"LAPACK_QRIteration()\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the QR Iteration algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.LAPACK_Simple","page":"Library","title":"MatrixAlgebraKit.LAPACK_Simple","text":"LAPACK_Simple()\n\nAlgorithm type to denote the simple LAPACK driver for computing the Schur or non-Hermitian eigenvalue decomposition of a matrix.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.NoTruncation","page":"Library","title":"MatrixAlgebraKit.NoTruncation","text":"NoTruncation()\n\nTrivial truncation strategy that keeps all values, mostly for testing purposes.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.PolarViaSVD","page":"Library","title":"MatrixAlgebraKit.PolarViaSVD","text":"PolarViaSVD(svdalg)\n\nAlgorithm for computing the polar decomposition of a matrix A via the singular value decomposition (SVD) of A. The svdalg argument specifies the SVD algorithm to use.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.TruncatedAlgorithm","page":"Library","title":"MatrixAlgebraKit.TruncatedAlgorithm","text":"TruncatedAlgorithm(alg::AbstractAlgorithm, trunc::TruncationAlgorithm)\n\nGeneric wrapper type for algorithms that consist of first using alg, followed by a truncation through trunc.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.TruncationKeepFiltered","page":"Library","title":"MatrixAlgebraKit.TruncationKeepFiltered","text":"TruncationKeepFiltered(filter::Function)\n\nTruncation strategy to keep the values for which filter returns true.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.TruncationKeepSorted","page":"Library","title":"MatrixAlgebraKit.TruncationKeepSorted","text":"TruncationKeepSorted(howmany::Int, sortby::Function, rev::Bool)\n\nTruncation strategy to keep the first howmany values when sorted according to sortby or the last howmany if rev is true.\n\n\n\n\n\n","category":"type"},{"location":"library/#MatrixAlgebraKit.TruncationStrategy","page":"Library","title":"MatrixAlgebraKit.TruncationStrategy","text":"abstract type TruncationStrategy end\n\nSupertype to denote different strategies for truncated decompositions that are implemented via post-truncation.\n\nSee also truncate!\n\n\n\n\n\n","category":"type"},{"location":"library/#Functions","page":"Library","title":"Functions","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [MatrixAlgebraKit]\nOrder   = [:function]","category":"page"},{"location":"library/#MatrixAlgebraKit.copy_input","page":"Library","title":"MatrixAlgebraKit.copy_input","text":"copy_input(f, A)\n\nPreprocess the input A for a given function, such that it may be handled correctly later. This may include a copy whenever the implementation would destroy the original matrix, or a change of element type to something that is supported.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.default_pullback_gaugetol-Tuple{Any}","page":"Library","title":"MatrixAlgebraKit.default_pullback_gaugetol","text":"default_pullback_gaugetol(a)\n\nDefault tolerance for deciding to warn if incoming adjoints of a pullback rule has components that are not gauge-invariant.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.defaulttol-Tuple{Any}","page":"Library","title":"MatrixAlgebraKit.defaulttol","text":"defaulttol(x)\n\nDefault tolerance or precision for a given object, e.g. to decide when it can be considerd to be zero or ignored in some other way, or how accurate some quantity needs to be computed.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.eig_full","page":"Library","title":"MatrixAlgebraKit.eig_full","text":"eig_full(A; kwargs...) -> D, V\neig_full(A, alg::AbstractAlgorithm) -> D, V\neig_full!(A, [DV]; kwargs...) -> D, V\neig_full!(A, [DV], alg::AbstractAlgorithm) -> D, V\n\nCompute the full eigenvalue decomposition of the square matrix A, such that A * V = V * D, where the invertible matrix V contains the eigenvectors and the diagonal matrix D contains the associated eigenvalues.\n\nnote: Note\nThe bang method eig_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eig_full and its variants do not assume additional structure on the input,\n\nand therefore will always return complex eigenvalues and eigenvectors. For the real eigenvalue decomposition of symmetric or hermitian operators, see eigh_full.\n\nSee also eig_vals(!) and eig_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eig_full!","page":"Library","title":"MatrixAlgebraKit.eig_full!","text":"eig_full(A; kwargs...) -> D, V\neig_full(A, alg::AbstractAlgorithm) -> D, V\neig_full!(A, [DV]; kwargs...) -> D, V\neig_full!(A, [DV], alg::AbstractAlgorithm) -> D, V\n\nCompute the full eigenvalue decomposition of the square matrix A, such that A * V = V * D, where the invertible matrix V contains the eigenvectors and the diagonal matrix D contains the associated eigenvalues.\n\nnote: Note\nThe bang method eig_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eig_full and its variants do not assume additional structure on the input,\n\nand therefore will always return complex eigenvalues and eigenvectors. For the real eigenvalue decomposition of symmetric or hermitian operators, see eigh_full.\n\nSee also eig_vals(!) and eig_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eig_trunc","page":"Library","title":"MatrixAlgebraKit.eig_trunc","text":"eig_trunc(A; kwargs...) -> D, V\neig_trunc(A, alg::AbstractAlgorithm) -> D, V\neig_trunc!(A, [DV]; kwargs...) -> D, V\neig_trunc!(A, [DV], alg::AbstractAlgorithm) -> D, V\n\nCompute a partial or truncated eigenvalue decomposition of the matrix A, such that A * V ≈ V * D, where the (possibly rectangular) matrix V contains  a subset of eigenvectors and the diagonal matrix D contains the associated eigenvalues, selected according to a truncation strategy.\n\nnote: Note\nThe bang method eig_trunc! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eig_full and its variants do not assume additional structure on the input,\n\nand therefore will always return complex eigenvalues and eigenvectors. For the real eigenvalue decomposition of symmetric or hermitian operators, see eigh_full.\n\nSee also eig_full(!) and eig_vals(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eig_trunc!","page":"Library","title":"MatrixAlgebraKit.eig_trunc!","text":"eig_trunc(A; kwargs...) -> D, V\neig_trunc(A, alg::AbstractAlgorithm) -> D, V\neig_trunc!(A, [DV]; kwargs...) -> D, V\neig_trunc!(A, [DV], alg::AbstractAlgorithm) -> D, V\n\nCompute a partial or truncated eigenvalue decomposition of the matrix A, such that A * V ≈ V * D, where the (possibly rectangular) matrix V contains  a subset of eigenvectors and the diagonal matrix D contains the associated eigenvalues, selected according to a truncation strategy.\n\nnote: Note\nThe bang method eig_trunc! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eig_full and its variants do not assume additional structure on the input,\n\nand therefore will always return complex eigenvalues and eigenvectors. For the real eigenvalue decomposition of symmetric or hermitian operators, see eigh_full.\n\nSee also eig_full(!) and eig_vals(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eig_vals","page":"Library","title":"MatrixAlgebraKit.eig_vals","text":"eig_vals(A; kwargs...) -> D\neig_vals(A, alg::AbstractAlgorithm) -> D\neig_vals!(A, [D]; kwargs...) -> D\neig_vals!(A, [D], alg::AbstractAlgorithm) -> D\n\nCompute the list of eigenvalues of A.\n\nnote: Note\nThe bang method eig_vals! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided D as output.\n\nnote: Note\nNote that eig_full and its variants do not assume additional structure on the input,\n\nand therefore will always return complex eigenvalues and eigenvectors. For the real eigenvalue decomposition of symmetric or hermitian operators, see eigh_full.\n\nSee also eig_full(!) and eig_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eig_vals!","page":"Library","title":"MatrixAlgebraKit.eig_vals!","text":"eig_vals(A; kwargs...) -> D\neig_vals(A, alg::AbstractAlgorithm) -> D\neig_vals!(A, [D]; kwargs...) -> D\neig_vals!(A, [D], alg::AbstractAlgorithm) -> D\n\nCompute the list of eigenvalues of A.\n\nnote: Note\nThe bang method eig_vals! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided D as output.\n\nnote: Note\nNote that eig_full and its variants do not assume additional structure on the input,\n\nand therefore will always return complex eigenvalues and eigenvectors. For the real eigenvalue decomposition of symmetric or hermitian operators, see eigh_full.\n\nSee also eig_full(!) and eig_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eigh_full","page":"Library","title":"MatrixAlgebraKit.eigh_full","text":"eigh_full(A; kwargs...) -> D, V\neigh_full(A, alg::AbstractAlgorithm) -> D, V\neigh_full!(A, [DV]; kwargs...) -> D, V\neigh_full!(A, [DV], alg::AbstractAlgorithm) -> D, V\n\nCompute the full eigenvalue decomposition of the symmetric or hermitian matrix A, such that A * V = V * D, where the unitary matrix V contains the orthogonal eigenvectors and the real diagonal matrix D contains the associated eigenvalues.\n\nnote: Note\nThe bang method eigh_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eigh_full and its variants assume additional structure on the input,\n\nand therefore will retain the eltype of the input for the eigenvalues and eigenvectors. For generic eigenvalue decompositions, see eig_full.\n\nSee also eigh_vals(!) and eigh_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eigh_full!","page":"Library","title":"MatrixAlgebraKit.eigh_full!","text":"eigh_full(A; kwargs...) -> D, V\neigh_full(A, alg::AbstractAlgorithm) -> D, V\neigh_full!(A, [DV]; kwargs...) -> D, V\neigh_full!(A, [DV], alg::AbstractAlgorithm) -> D, V\n\nCompute the full eigenvalue decomposition of the symmetric or hermitian matrix A, such that A * V = V * D, where the unitary matrix V contains the orthogonal eigenvectors and the real diagonal matrix D contains the associated eigenvalues.\n\nnote: Note\nThe bang method eigh_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eigh_full and its variants assume additional structure on the input,\n\nand therefore will retain the eltype of the input for the eigenvalues and eigenvectors. For generic eigenvalue decompositions, see eig_full.\n\nSee also eigh_vals(!) and eigh_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eigh_trunc","page":"Library","title":"MatrixAlgebraKit.eigh_trunc","text":"eigh_trunc(A; kwargs...) -> D, V\neigh_trunc(A, alg::AbstractAlgorithm) -> D, V\neigh_trunc!(A, [DV]; kwargs...) -> D, V\neigh_trunc!(A, [DV], alg::AbstractAlgorithm) -> D, V\n\nCompute a partial or truncated eigenvalue decomposition of the symmetric or hermitian matrix A, such that A * V ≈ V * D, where the isometric matrix V contains a subset of the orthogonal eigenvectors and the real diagonal matrix D contains the associated eigenvalues, selected according to a truncation strategy. \n\nnote: Note\nThe bang method eigh_trunc! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eigh_full and its variants assume additional structure on the input,\n\nand therefore will retain the eltype of the input for the eigenvalues and eigenvectors. For generic eigenvalue decompositions, see eig_full.\n\nSee also eigh_full(!) and eigh_vals(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eigh_trunc!","page":"Library","title":"MatrixAlgebraKit.eigh_trunc!","text":"eigh_trunc(A; kwargs...) -> D, V\neigh_trunc(A, alg::AbstractAlgorithm) -> D, V\neigh_trunc!(A, [DV]; kwargs...) -> D, V\neigh_trunc!(A, [DV], alg::AbstractAlgorithm) -> D, V\n\nCompute a partial or truncated eigenvalue decomposition of the symmetric or hermitian matrix A, such that A * V ≈ V * D, where the isometric matrix V contains a subset of the orthogonal eigenvectors and the real diagonal matrix D contains the associated eigenvalues, selected according to a truncation strategy. \n\nnote: Note\nThe bang method eigh_trunc! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eigh_full and its variants assume additional structure on the input,\n\nand therefore will retain the eltype of the input for the eigenvalues and eigenvectors. For generic eigenvalue decompositions, see eig_full.\n\nSee also eigh_full(!) and eigh_vals(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eigh_vals","page":"Library","title":"MatrixAlgebraKit.eigh_vals","text":"eigh_vals(A; kwargs...) -> D\neigh_vals(A, alg::AbstractAlgorithm) -> D\neigh_vals!(A, [D]; kwargs...) -> D\neigh_vals!(A, [D], alg::AbstractAlgorithm) -> D\n\nCompute the list of (real) eigenvalues of the symmetric or hermitian matrix A.\n\nnote: Note\nThe bang method eigh_vals! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eigh_full and its variants assume additional structure on the input,\n\nand therefore will retain the eltype of the input for the eigenvalues and eigenvectors. For generic eigenvalue decompositions, see eig_full.\n\nSee also eigh_full(!) and eigh_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.eigh_vals!","page":"Library","title":"MatrixAlgebraKit.eigh_vals!","text":"eigh_vals(A; kwargs...) -> D\neigh_vals(A, alg::AbstractAlgorithm) -> D\neigh_vals!(A, [D]; kwargs...) -> D\neigh_vals!(A, [D], alg::AbstractAlgorithm) -> D\n\nCompute the list of (real) eigenvalues of the symmetric or hermitian matrix A.\n\nnote: Note\nThe bang method eigh_vals! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eigh_full and its variants assume additional structure on the input,\n\nand therefore will retain the eltype of the input for the eigenvalues and eigenvectors. For generic eigenvalue decompositions, see eig_full.\n\nSee also eigh_full(!) and eigh_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.initialize_output","page":"Library","title":"MatrixAlgebraKit.initialize_output","text":"initialize_output(f, A, alg)\n\nWhenever possible, allocate the destination for applying a given algorithm in-place. If this is not possible, for example when the output size is not known a priori or immutable, this function may return nothing.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.inv_regularized","page":"Library","title":"MatrixAlgebraKit.inv_regularized","text":"inv_regularized(a::Number, tol=defaulttol(a))\ninv_regularized(A::Matrix, tol=defaulttol(A); isposdef = false, kwargs...)\n\nCompute a smooth regularised inverse (L2 Tikhonov regularisation) of a number or square  matrix a.\n\nFor numbers, this is given by inv(hypot(a, tol)).\nFor matrices, this is computed using the singular value decomposition and aplying   inv_regularized to the singular values. If isposdef = true, the singular value   decomposition is equivalent to the (Hermitian) eigenvalue decomposition of A and   the latter is used instead.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.inv_safe","page":"Library","title":"MatrixAlgebraKit.inv_safe","text":"function inv_safe(a::Number, tol=defaulttol(a))\n\nCompute the inverse of a number a, but return zero if a is smaller than tol.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.iszerotangent","page":"Library","title":"MatrixAlgebraKit.iszerotangent","text":"iszerotangent(x)\n\nReturn true if x is of a type that the different AD engines use to communicate a (co)tangent that is identically zero. By overloading this method, and writing pullback definitions in term of it, we will be able to hook into different AD ecosystems\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.left_null","page":"Library","title":"MatrixAlgebraKit.left_null","text":"left_null(A; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -> N\nleft_null!(A, [N]; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -> N\n\nCompute an orthonormal basis N for the cokernel of the matrix A of size (m, n), i.e. the nullspace of adjoint(A), such that adjoint(A)*N ≈ 0 and N'*N ≈ I. The keyword argument kind can be used to specify the specific orthogonal decomposition that should be used to factor A, whereas atol and rtol can be used to control the precision in determining the rank of A via its singular values.\n\nThis is a high-level wrapper and will use one of the decompositions qr! or svd! to compute the orthogonal basis N, as controlled by the keyword arguments.\n\nWhen kind is provided, its possible values are\n\nkind == :qrpos: N is computed using the positive QR decomposition.   This requires iszero(atol) && iszero(rtol) and left_null!(A, [N], kind=:qrpos) is equivalent to   qr_null!(A, [N], alg) with a default value alg = select_algorithm(qr_compact!, A; positive=true)\nkind == :qr: N is computed using the (nonpositive) QR decomposition.   This requires iszero(atol) && iszero(rtol) and left_null!(A, [N], kind=:qr) is equivalent to   qr_null!(A, [N], alg) with a default value alg = select_algorithm(qr_compact!, A)\nkind == :svd: N is computed using the singular value decomposition and will contain    the left singular vectors corresponding to the singular values that   are smaller than max(atol, rtol * σ₁), where σ₁ is the largest singular value of A.\n\nWhen kind is not provided, the default value is :qrpos when iszero(atol) && iszero(rtol) and :svd otherwise. Finally, finer control is obtained by providing an explicit algorithm using the alg keyword argument, which should be compatible with the chosen or default value of kind.\n\nnote: Note\nThe bang method left_null! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided N as output.\n\nSee also right_null(!), left_orth(!), right_orth(!)\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.left_orth","page":"Library","title":"MatrixAlgebraKit.left_orth","text":"left_orth(A; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -> V, C\nleft_orth!(A, [VC]; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -> V, C\n\nCompute an orthonormal basis V for the image of the matrix A of size (m, n), as well as a  matrix C (the corestriction) such that A factors as A = V * C. The keyword argument kind can be used to specify the specific orthogonal decomposition that should be used to factor A, whereas atol and rtol can be used to control the precision in determining the rank of A via its singular values.\n\nThis is a high-level wrapper and will use one of the decompositions qr!, svd!, and left_polar! to compute the orthogonal basis V, as controlled by the keyword arguments.\n\nWhen kind is provided, its possible values are\n\nkind == :qrpos: V and C are computed using the positive QR decomposition.   This requires iszero(atol) && iszero(rtol) and left_orth!(A, [VC]) is equivalent to   qr_compact!(A, [VC], alg) with a default value alg = select_algorithm(qr_compact!, A; positive=true)\nkind == :qr: V and C are computed using the QR decomposition,   This requires iszero(atol) && iszero(rtol) and left_orth!(A, [VC]) is equivalent to   qr_compact!(A, [VC], alg) with a default value alg = select_algorithm(qr_compact!, A)\nkind == :polar: V and C are computed using the polar decomposition,   This requires iszero(atol) && iszero(rtol) and left_orth!(A, [VC]) is equivalent to   left_polar!(A, [VC], alg) with a default value alg = select_algorithm(left_polar!, A)\nkind == :svd: V and C are computed using the singular value decomposition svd_trunc!,   where V will contain the left singular vectors corresponding to the singular values that   are larger than max(atol, rtol * σ₁), where σ₁ is the largest singular value of A.   C is computed as the product of the singular values and the right singular vectors,   i.e. with U, S, Vᴴ = svd_trunc!(A), we have V = U and C = S * Vᴴ.\n\nWhen kind is not provided, the default value is :qrpos when iszero(atol) && iszero(rtol) and :svd otherwise. Finally, finer control is obtained by providing an explicit algorithm using the alg keyword argument, which should be compatible with the chosen or default value of kind.\n\nnote: Note\nThe bang method left_orth! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided CV as output.\n\nSee also right_orth(!), left_orth(!), right_orth(!)\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.left_polar","page":"Library","title":"MatrixAlgebraKit.left_polar","text":"left_polar(A; kwargs...) -> W, P\nleft_polar(A, alg::AbstractAlgorithm) -> W, P\nleft_polar!(A, [WP]; kwargs...) -> W, P\nleft_polar!(A, [WP], alg::AbstractAlgorithm) -> W, P\n\nCompute the full polar decomposition of the rectangular matrix A of size (m, n) with m >= n, such that A = W * P. Here, W is an isometric matrix (orthonormal columns) of size (m, n), whereas P is a positive (semi)definite matrix of size (n, n).\n\nnote: Note\nThe bang method left_polar! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided WP as output.\n\nSee also right_polar(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.left_polar!","page":"Library","title":"MatrixAlgebraKit.left_polar!","text":"left_polar(A; kwargs...) -> W, P\nleft_polar(A, alg::AbstractAlgorithm) -> W, P\nleft_polar!(A, [WP]; kwargs...) -> W, P\nleft_polar!(A, [WP], alg::AbstractAlgorithm) -> W, P\n\nCompute the full polar decomposition of the rectangular matrix A of size (m, n) with m >= n, such that A = W * P. Here, W is an isometric matrix (orthonormal columns) of size (m, n), whereas P is a positive (semi)definite matrix of size (n, n).\n\nnote: Note\nThe bang method left_polar! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided WP as output.\n\nSee also right_polar(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.left_polar_pullback!-Tuple{AbstractMatrix, Any, Any}","page":"Library","title":"MatrixAlgebraKit.left_polar_pullback!","text":"left_polar_pullback!(ΔA, (W, P), (ΔW, ΔP))\n\nAdds the pullback from the left polar decomposition of A to ΔA given the output (W, P) and cotangent (ΔW, ΔP) of left_polar(A).                        \n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.lq_compact","page":"Library","title":"MatrixAlgebraKit.lq_compact","text":"lq_compact(A; kwargs...) -> L, Q\nlq_compact(A, alg::AbstractAlgorithm) -> L, Q\nlq_compact!(A, [LQ]; kwargs...) -> L, Q\nlq_compact!(A, [LQ], alg::AbstractAlgorithm) -> L, Q\n\nCompute the compact LQ decomposition of the rectangular matrix A of size (m,n), such that A = L * Q where the matrix Q of size (min(m,n), n) has orthogonal rows spanning the image of A', and the matrix L of size (m, min(m,n)) is lower triangular.\n\nnote: Note\nThe bang method lq_compact! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided LQ as output.\n\nnote: Note\nThe compact QR decomposition is equivalent to the full LQ decomposition when m >= n. Some algorithms may require m <= n.\n\nSee also lq_full(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.lq_compact!","page":"Library","title":"MatrixAlgebraKit.lq_compact!","text":"lq_compact(A; kwargs...) -> L, Q\nlq_compact(A, alg::AbstractAlgorithm) -> L, Q\nlq_compact!(A, [LQ]; kwargs...) -> L, Q\nlq_compact!(A, [LQ], alg::AbstractAlgorithm) -> L, Q\n\nCompute the compact LQ decomposition of the rectangular matrix A of size (m,n), such that A = L * Q where the matrix Q of size (min(m,n), n) has orthogonal rows spanning the image of A', and the matrix L of size (m, min(m,n)) is lower triangular.\n\nnote: Note\nThe bang method lq_compact! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided LQ as output.\n\nnote: Note\nThe compact QR decomposition is equivalent to the full LQ decomposition when m >= n. Some algorithms may require m <= n.\n\nSee also lq_full(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.lq_compact_pullback!-Tuple{AbstractMatrix, Any, Any}","page":"Library","title":"MatrixAlgebraKit.lq_compact_pullback!","text":"lq_compact_pullback!(ΔA, (L, Q), (ΔL, ΔQ);\n                        tol::Real=default_pullback_gaugetol(R),\n                        rank_atol::Real=tol,\n                        gauge_atol::Real=tol)\n\nAdds the pullback from the LQ decomposition of A to ΔA given the output (L, Q) and cotangent (ΔL, ΔQ) of lq_compact(A; positive=true) or lq_full(A; positive=true).\n\nIn the case where the rank r of the original matrix A ≈ L * Q (as determined by rank_atol) is less then the  minimum of the number of rows and columns , the cotangents ΔL and ΔQ, only the first r columns of L and the first r rows of Q are well-defined, and also the adjoint variables ΔL and ΔQ should have nonzero values only in the first r columns and rows respectively. If nonzero values in the remaining columns or rows exceed gauge_atol, a warning will be printed.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.lq_full","page":"Library","title":"MatrixAlgebraKit.lq_full","text":"lq_full(A; kwargs...) -> L, Q\nlq_full(A, alg::AbstractAlgorithm) -> L, Q\nlq_full!(A, [LQ]; kwargs...) -> L, Q\nlq_full!(A, [LQ], alg::AbstractAlgorithm) -> L, Q\n\nCompute the full LQ decomposition of the rectangular matrix A, such that A = L * Q where Q is a square unitary matrix with the same number of rows as A and L is a lower triangular matrix with the same size as A.\n\nnote: Note\nThe bang method lq_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided LQ as output.\n\nSee also lq_compact(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.lq_full!","page":"Library","title":"MatrixAlgebraKit.lq_full!","text":"lq_full(A; kwargs...) -> L, Q\nlq_full(A, alg::AbstractAlgorithm) -> L, Q\nlq_full!(A, [LQ]; kwargs...) -> L, Q\nlq_full!(A, [LQ], alg::AbstractAlgorithm) -> L, Q\n\nCompute the full LQ decomposition of the rectangular matrix A, such that A = L * Q where Q is a square unitary matrix with the same number of rows as A and L is a lower triangular matrix with the same size as A.\n\nnote: Note\nThe bang method lq_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided LQ as output.\n\nSee also lq_compact(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.lq_null","page":"Library","title":"MatrixAlgebraKit.lq_null","text":"lq_null(A; kwargs...) -> Nᴴ\nlq_null(A, alg::AbstractAlgorithm) -> Nᴴ\nlq_null!(A, [Nᴴ]; kwargs...) -> Nᴴ\nlq_null!(A, [Nᴴ], alg::AbstractAlgorithm) -> Nᴴ\n\nFor a (m, n) matrix A, compute the matrix Nᴴ corresponding the final n - min(m, n) rows  oft the unitary Q factor in the full LQ decomposition of A, i.e. the rows that are not present in the Q factor of the compact LQ decomposition. The matrix Nᴴ is such that the isometric matrix N = adjoint(Nᴴ) contains an orthonormal basis for the kernel (null space) of A as its columns, i.e. A * N = 0 or thus A * adjoint(Nᴴ) = 0.\n\nnote: Note\nThe bang method lq_null! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided Nᴴ argument as output.\n\nnote: Note\nThe matrix Nᴴ is empty when m >= n.\n\nSee also qr_full(!) and qr_compact(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.lq_null!","page":"Library","title":"MatrixAlgebraKit.lq_null!","text":"lq_null(A; kwargs...) -> Nᴴ\nlq_null(A, alg::AbstractAlgorithm) -> Nᴴ\nlq_null!(A, [Nᴴ]; kwargs...) -> Nᴴ\nlq_null!(A, [Nᴴ], alg::AbstractAlgorithm) -> Nᴴ\n\nFor a (m, n) matrix A, compute the matrix Nᴴ corresponding the final n - min(m, n) rows  oft the unitary Q factor in the full LQ decomposition of A, i.e. the rows that are not present in the Q factor of the compact LQ decomposition. The matrix Nᴴ is such that the isometric matrix N = adjoint(Nᴴ) contains an orthonormal basis for the kernel (null space) of A as its columns, i.e. A * N = 0 or thus A * adjoint(Nᴴ) = 0.\n\nnote: Note\nThe bang method lq_null! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided Nᴴ argument as output.\n\nnote: Note\nThe matrix Nᴴ is empty when m >= n.\n\nSee also qr_full(!) and qr_compact(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.qr_compact","page":"Library","title":"MatrixAlgebraKit.qr_compact","text":"qr_compact(A; kwargs...) -> Q, R\nqr_compact(A, alg::AbstractAlgorithm) -> Q, R\nqr_compact!(A, [QR]; kwargs...) -> Q, R\nqr_compact!(A, [QR], alg::AbstractAlgorithm) -> Q, R\n\nCompute the compact QR decomposition of the rectangular matrix A of size (m,n), such that A = Q * R where the isometric matrix Q of size (m, min(m,n)) has orthogonal columns spanning the image of A, and the matrix R of size (min(m,n), n) is upper triangular.\n\nnote: Note\nThe bang method qr_compact! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided QR as output.\n\nnote: Note\nThe compact QR decomposition is equivalent to the full QR decomposition when m >= n. Some algorithms may require m >= n.\n\nSee also qr_full(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.qr_compact!","page":"Library","title":"MatrixAlgebraKit.qr_compact!","text":"qr_compact(A; kwargs...) -> Q, R\nqr_compact(A, alg::AbstractAlgorithm) -> Q, R\nqr_compact!(A, [QR]; kwargs...) -> Q, R\nqr_compact!(A, [QR], alg::AbstractAlgorithm) -> Q, R\n\nCompute the compact QR decomposition of the rectangular matrix A of size (m,n), such that A = Q * R where the isometric matrix Q of size (m, min(m,n)) has orthogonal columns spanning the image of A, and the matrix R of size (min(m,n), n) is upper triangular.\n\nnote: Note\nThe bang method qr_compact! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided QR as output.\n\nnote: Note\nThe compact QR decomposition is equivalent to the full QR decomposition when m >= n. Some algorithms may require m >= n.\n\nSee also qr_full(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.qr_compact_pullback!-Tuple{AbstractMatrix, Any, Any}","page":"Library","title":"MatrixAlgebraKit.qr_compact_pullback!","text":"qr_compact_pullback!(ΔA, (Q, R), (ΔQ, ΔR);\n                        tol::Real=default_pullback_gaugetol(R),\n                        rank_atol::Real=tol,\n                        gauge_atol::Real=tol)\n\nAdds the pullback from the QR decomposition of A to ΔA given the output (Q,R) and cotangent (ΔQ, ΔR) of qr_compact(A; positive=true) or qr_full(A; positive=true).\n\nIn the case where the rank r of the original matrix A ≈ Q * R (as determined by rank_atol) is less then the minimum of the number of rows and columns, the cotangents ΔQ and ΔR, only the first r columns of Q and the first r rows of R are well-defined, and also the adjoint variables ΔQ and ΔR should have nonzero values only in the first r columns and rows respectively. If nonzero values in the remaining columns or rows exceed gauge_atol, a warning will be printed.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.qr_full","page":"Library","title":"MatrixAlgebraKit.qr_full","text":"qr_full(A; kwargs...) -> Q, R\nqr_full(A, alg::AbstractAlgorithm) -> Q, R\nqr_full!(A, [QR]; kwargs...) -> Q, R\nqr_full!(A, [QR], alg::AbstractAlgorithm) -> Q, R\n\nCompute the full QR decomposition of the rectangular matrix A, such that A = Q * R where Q is a square unitary matrix with the same number of rows as A and R is an upper triangular matrix with the same size as A.\n\nnote: Note\nThe bang method qr_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided QR as output.\n\nSee also qr_compact(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.qr_full!","page":"Library","title":"MatrixAlgebraKit.qr_full!","text":"qr_full(A; kwargs...) -> Q, R\nqr_full(A, alg::AbstractAlgorithm) -> Q, R\nqr_full!(A, [QR]; kwargs...) -> Q, R\nqr_full!(A, [QR], alg::AbstractAlgorithm) -> Q, R\n\nCompute the full QR decomposition of the rectangular matrix A, such that A = Q * R where Q is a square unitary matrix with the same number of rows as A and R is an upper triangular matrix with the same size as A.\n\nnote: Note\nThe bang method qr_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided QR as output.\n\nSee also qr_compact(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.qr_null","page":"Library","title":"MatrixAlgebraKit.qr_null","text":"qr_null(A; kwargs...) -> N\nqr_null(A, alg::AbstractAlgorithm) -> N\nqr_null!(A, [N]; kwargs...) -> N\nqr_null!(A, [N], alg::AbstractAlgorithm) -> N\n\nFor a (m, n) matrix A, compute the matrix N corresponding the final m - min(m, n) columns  of the unitary Q factor in the full QR decomposition of A, i.e. the columns that are not present in the Q factor of the compact QR decomposition. The isometric matrix N contains an orthonormal basis for the cokernel of A as its columns, i.e. adjoint(A) * N = 0.\n\nnote: Note\nThe bang method qr_null! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided N argument as output.\n\nnote: Note\nThe matrix N is empty when m <= n.\n\nSee also lq_full(!) and lq_compact(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.qr_null!","page":"Library","title":"MatrixAlgebraKit.qr_null!","text":"qr_null(A; kwargs...) -> N\nqr_null(A, alg::AbstractAlgorithm) -> N\nqr_null!(A, [N]; kwargs...) -> N\nqr_null!(A, [N], alg::AbstractAlgorithm) -> N\n\nFor a (m, n) matrix A, compute the matrix N corresponding the final m - min(m, n) columns  of the unitary Q factor in the full QR decomposition of A, i.e. the columns that are not present in the Q factor of the compact QR decomposition. The isometric matrix N contains an orthonormal basis for the cokernel of A as its columns, i.e. adjoint(A) * N = 0.\n\nnote: Note\nThe bang method qr_null! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided N argument as output.\n\nnote: Note\nThe matrix N is empty when m <= n.\n\nSee also lq_full(!) and lq_compact(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.right_null","page":"Library","title":"MatrixAlgebraKit.right_null","text":"right_null(A; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -> Nᴴ\nright_null!(A, [Nᴴ]; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -> Nᴴ\n\nCompute an orthonormal basis N = adjoint(Nᴴ) for the kernel or nullspace of the matrix A of size (m, n), such that A*adjoint(Nᴴ) ≈ 0 and Nᴴ*adjoint(Nᴴ) ≈ I. The keyword argument kind can be used to specify the specific orthogonal decomposition that should be used to factor A, whereas atol and rtol can be used to control the precision in determining the rank of A via its singular values.\n\nThis is a high-level wrapper and will use one of the decompositions lq! or svd! to compute the orthogonal basis Nᴴ, as controlled by the keyword arguments.\n\nWhen kind is provided, its possible values are\n\nkind == :lqpos: Nᴴ is computed using the positive LQ decomposition.   This requires iszero(atol) && iszero(rtol) and right_null!(A, [Nᴴ], kind=:lqpos) is equivalent to   lq_null!(A, [Nᴴ], alg) with a default value alg = select_algorithm(lq_compact!, A; positive=true)\nkind == :lq: Nᴴ is computed using the (nonpositive) LQ decomposition.   This requires iszero(atol) && iszero(rtol) and right_null!(A, [Nᴴ], kind=:lq) is equivalent to   lq_null!(A, [Nᴴ], alg) with a default value alg = select_algorithm(lq_compact!, A)\nkind == :svd: N is computed using the singular value decomposition and will contain    the left singular vectors corresponding to the singular values that   are smaller than max(atol, rtol * σ₁), where σ₁ is the largest singular value of A.\n\nWhen kind is not provided, the default value is :lqpos when iszero(atol) && iszero(rtol) and :svd otherwise. Finally, finer control is obtained by providing an explicit algorithm using the alg keyword argument, which should be compatible with the chosen or default value of kind.\n\nnote: Note\nThe bang method right_null! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided Nᴴ as output.\n\nSee also left_null(!), left_orth(!), right_orth(!)\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.right_orth","page":"Library","title":"MatrixAlgebraKit.right_orth","text":"right_orth(A; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -> C, Vᴴ\nright_orth!(A, [CVᴴ]; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -> C, Vᴴ\n\nCompute an orthonormal basis V = adjoint(Vᴴ) for the coimage of the matrix A, i.e. for the image of adjoint(A), as well as a matrix C such that A = C * Vᴴ. The keyword argument kind can be used to specify the specific orthogonal decomposition that should be used to factor A, whereas atol and rtol can be used to control the precision in determining the rank of A via its singular values.\n\nThis is a high-level wrapper and will use call one of the decompositions qr!, svd!, and left_polar! to compute the orthogonal basis V, as controlled by the keyword arguments.\n\nWhen kind is provided, its possible values are\n\nkind == :lqpos: C and Vᴴ are computed using the positive QR decomposition.   This requires iszero(atol) && iszero(rtol) and right_orth!(A, [CVᴴ]) is equivalent to   lq_compact!(A, [CVᴴ], alg) with a default value alg = select_algorithm(lq_compact!, A; positive=true)\nkind == :lq: C and Vᴴ are computed using the QR decomposition,   This requires iszero(atol) && iszero(rtol) and right_orth!(A, [CVᴴ]) is equivalent to   lq_compact!(A, [CVᴴ], alg) with a default value alg = select_algorithm(lq_compact!, A))\nkind == :polar: C and Vᴴ are computed using the polar decomposition,   This requires iszero(atol) && iszero(rtol) and right_orth!(A, [CVᴴ]) is equivalent to   right_polar!(A, [CVᴴ], alg) with a default value alg = select_algorithm(right_polar!, A))\nkind == :svd: C and Vᴴ are computed using the singular value decomposition svd_trunc!,   where V = adjoint(Vᴴ) will contain the right singular vectors corresponding to the singular   values that are larger than max(atol, rtol * σ₁), where σ₁ is the largest singular value of A.   C is computed as the product of the singular values and the right singular vectors,   i.e. with U, S, Vᴴ = svd_trunc!(A), we have C = rmul!(U, S) and Vᴴ = Vᴴ.\n\nWhen kind is not provided, the default value is :lqpos when iszero(atol) && iszero(rtol) and :svd otherwise. Finally, finer control is obtained by providing an explicit algorithm using the alg keyword argument, which should be compatible with the chosen or default value of kind.\n\nnote: Note\nThe bang method right_orth! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided CVᴴ as output.\n\nSee also left_orth(!), left_orth(!), right_orth(!)\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.right_polar","page":"Library","title":"MatrixAlgebraKit.right_polar","text":"right_polar(A; kwargs...) -> P, Wᴴ\nright_polar(A, alg::AbstractAlgorithm) -> P, Wᴴ\nright_polar!(A, [PWᴴ]; kwargs...) -> P, Wᴴ\nright_polar!(A, [PWᴴ], alg::AbstractAlgorithm) -> P, Wᴴ\n\nCompute the full polar decomposition of the rectangular matrix A of size (m, n) with n >= m, such that A = P * Wᴴ. Here, P is a positive (semi)definite matrix of size (m, m), whereas Wᴴ is a matrix with orthonormal rows (its adjoint is isometric) of size (n, m).\n\nnote: Note\nThe bang method right_polar! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided WP as output.\n\nSee also left_polar(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.right_polar!","page":"Library","title":"MatrixAlgebraKit.right_polar!","text":"right_polar(A; kwargs...) -> P, Wᴴ\nright_polar(A, alg::AbstractAlgorithm) -> P, Wᴴ\nright_polar!(A, [PWᴴ]; kwargs...) -> P, Wᴴ\nright_polar!(A, [PWᴴ], alg::AbstractAlgorithm) -> P, Wᴴ\n\nCompute the full polar decomposition of the rectangular matrix A of size (m, n) with n >= m, such that A = P * Wᴴ. Here, P is a positive (semi)definite matrix of size (m, m), whereas Wᴴ is a matrix with orthonormal rows (its adjoint is isometric) of size (n, m).\n\nnote: Note\nThe bang method right_polar! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided WP as output.\n\nSee also left_polar(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.right_polar_pullback!-Tuple{AbstractMatrix, Any, Any}","page":"Library","title":"MatrixAlgebraKit.right_polar_pullback!","text":"right_polar_pullback!(ΔA, (P, Wᴴ), (ΔP, ΔWᴴ))\n\nAdds the pullback from the left polar decomposition of A to ΔA given the output (P, Wᴴ) and cotangent (ΔP, ΔWᴴ) of right_polar(A).                        \n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.schur_full","page":"Library","title":"MatrixAlgebraKit.schur_full","text":"schur_full(A; kwargs...) -> T, Z, vals\nschur_full(A, alg::AbstractAlgorithm) -> T, Z, vals\nschur_full!(A, [TZv]; kwargs...) -> T, Z, vals\nschur_full!(A, [TZv], alg::AbstractAlgorithm) -> T, Z, vals\n\nCompute the full Schur decomposition of the square matrix A, such that A * Z = Z * T, where the orthogonal or unitary matrix Z contains the Schur vectors and the square matrix T is upper triangular (in the complex case) or quasi-upper triangular (in the real case). The list vals contains the (complex-valued) eigenvalues of A, as extracted from the (quasi-)diagonal of T.\n\nnote: Note\nThe bang method schur_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided TZv as output.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.schur_full!","page":"Library","title":"MatrixAlgebraKit.schur_full!","text":"schur_full(A; kwargs...) -> T, Z, vals\nschur_full(A, alg::AbstractAlgorithm) -> T, Z, vals\nschur_full!(A, [TZv]; kwargs...) -> T, Z, vals\nschur_full!(A, [TZv], alg::AbstractAlgorithm) -> T, Z, vals\n\nCompute the full Schur decomposition of the square matrix A, such that A * Z = Z * T, where the orthogonal or unitary matrix Z contains the Schur vectors and the square matrix T is upper triangular (in the complex case) or quasi-upper triangular (in the real case). The list vals contains the (complex-valued) eigenvalues of A, as extracted from the (quasi-)diagonal of T.\n\nnote: Note\nThe bang method schur_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided TZv as output.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.schur_vals","page":"Library","title":"MatrixAlgebraKit.schur_vals","text":"schur_vals(A; kwargs...) -> vals\nschur_vals(A, alg::AbstractAlgorithm) -> vals\nschur_vals!(A, [vals]; kwargs...) -> vals\nschur_vals!(A, [vals], alg::AbstractAlgorithm) -> vals\n\nCompute the list of eigenvalues of A by computing the Schur decomposition of A.\n\nnote: Note\nThe bang method schur_vals! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided vals as output.\n\nSee also eig_full(!) and eig_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.schur_vals!","page":"Library","title":"MatrixAlgebraKit.schur_vals!","text":"schur_vals(A; kwargs...) -> vals\nschur_vals(A, alg::AbstractAlgorithm) -> vals\nschur_vals!(A, [vals]; kwargs...) -> vals\nschur_vals!(A, [vals], alg::AbstractAlgorithm) -> vals\n\nCompute the list of eigenvalues of A by computing the Schur decomposition of A.\n\nnote: Note\nThe bang method schur_vals! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided vals as output.\n\nSee also eig_full(!) and eig_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.select_algorithm","page":"Library","title":"MatrixAlgebraKit.select_algorithm","text":"select_algorithm(f, A; kwargs...)\n\nGiven some keyword arguments and an input A, decide on an algrithm to use for implementing the function f on inputs of type A.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.sign_safe-Tuple{Real}","page":"Library","title":"MatrixAlgebraKit.sign_safe","text":"sign_safe(s::Number)\n\nCompute the sign of a number s, but return +1 if s is zero so that the result is always a number with modulus 1, i.e. an element of the unitary group U(1).\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.svd_compact","page":"Library","title":"MatrixAlgebraKit.svd_compact","text":"svd_compact(A; kwargs...) -> U, S, Vᴴ\nsvd_compact(A, alg::AbstractAlgorithm) -> U, S, Vᴴ\nsvd_compact!(A, [USVᴴ]; kwargs...) -> U, S, Vᴴ\nsvd_compact!(A, [USVᴴ], alg::AbstractAlgorithm) -> U, S, Vᴴ\n\nCompute the compact singular value decomposition (SVD) of the rectangular matrix A of size (m, n), such that A = U * S * Vᴴ. Here, U is an isometric matrix (orthonormal columns) of size (m, k), whereas  Vᴴ is a matrix of size (k, n) with orthonormal rows and S is a square diagonal matrix of size (k, k), with k = min(m, n).\n\nnote: Note\nThe bang method svd_compact! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided USVᴴ as output.\n\nSee also svd_full(!), svd_vals(!) and svd_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.svd_compact!","page":"Library","title":"MatrixAlgebraKit.svd_compact!","text":"svd_compact(A; kwargs...) -> U, S, Vᴴ\nsvd_compact(A, alg::AbstractAlgorithm) -> U, S, Vᴴ\nsvd_compact!(A, [USVᴴ]; kwargs...) -> U, S, Vᴴ\nsvd_compact!(A, [USVᴴ], alg::AbstractAlgorithm) -> U, S, Vᴴ\n\nCompute the compact singular value decomposition (SVD) of the rectangular matrix A of size (m, n), such that A = U * S * Vᴴ. Here, U is an isometric matrix (orthonormal columns) of size (m, k), whereas  Vᴴ is a matrix of size (k, n) with orthonormal rows and S is a square diagonal matrix of size (k, k), with k = min(m, n).\n\nnote: Note\nThe bang method svd_compact! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided USVᴴ as output.\n\nSee also svd_full(!), svd_vals(!) and svd_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.svd_compact_pullback!-Tuple{AbstractMatrix, Any, Any}","page":"Library","title":"MatrixAlgebraKit.svd_compact_pullback!","text":"svd_compact_pullback!(ΔA, USVᴴ, ΔUSVᴴ;\n                        tol::Real=default_pullback_gaugetol(S),\n                        rank_atol::Real = tol,\n                        degeneracy_atol::Real = tol,\n                        gauge_atol::Real = tol)\n\nAdds the pullback from the SVD of A to ΔA given the output USVᴴ of svd_compact or svd_full and the cotangent ΔUSVᴴ of svd_compact, svd_full or svd_trunc.\n\nIn particular, it is assumed that A ≈ U * S * Vᴴ, or thus, that no singular values with magnitude less than rank_atol are missing from S. For the cotangents, an arbitrary number of singular vectors or singular values can be missing, i.e. ΔU and ΔVᴴ can have sizes (m, pU) and (pV, n) respectively, whereas diagview(ΔS) can have length pS.\n\nA warning will be printed if the cotangents are not gauge-invariant, i.e. if the anti-hermitian part of U' * ΔU + Vᴴ * ΔVᴴ', restricted to rows i and columns j for which abs(S[i] - S[j]) < degeneracy_atol, is not small compared to gauge_atol.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.svd_full","page":"Library","title":"MatrixAlgebraKit.svd_full","text":"svd_full(A; kwargs...) -> U, S, Vᴴ\nsvd_full(A, alg::AbstractAlgorithm) -> U, S, Vᴴ\nsvd_full!(A, [USVᴴ]; kwargs...) -> U, S, Vᴴ\nsvd_full!(A, [USVᴴ], alg::AbstractAlgorithm) -> U, S, Vᴴ\n\nCompute the full singular value decomposition (SVD) of the rectangular matrix A of size (m, n), such that A = U * S * Vᴴ. Here, U and Vᴴ are unitary matrices of size (m, m) and (n, n) respectively, and S is a diagonal matrix of size (m, n).\n\nnote: Note\nThe bang method svd_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided USVᴴ as output.\n\nSee also svd_compact(!), svd_vals(!) and svd_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.svd_full!","page":"Library","title":"MatrixAlgebraKit.svd_full!","text":"svd_full(A; kwargs...) -> U, S, Vᴴ\nsvd_full(A, alg::AbstractAlgorithm) -> U, S, Vᴴ\nsvd_full!(A, [USVᴴ]; kwargs...) -> U, S, Vᴴ\nsvd_full!(A, [USVᴴ], alg::AbstractAlgorithm) -> U, S, Vᴴ\n\nCompute the full singular value decomposition (SVD) of the rectangular matrix A of size (m, n), such that A = U * S * Vᴴ. Here, U and Vᴴ are unitary matrices of size (m, m) and (n, n) respectively, and S is a diagonal matrix of size (m, n).\n\nnote: Note\nThe bang method svd_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided USVᴴ as output.\n\nSee also svd_compact(!), svd_vals(!) and svd_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.svd_trunc","page":"Library","title":"MatrixAlgebraKit.svd_trunc","text":"svd_trunc(A; kwargs...) -> U, S, Vᴴ\nsvd_trunc(A, alg::AbstractAlgorithm) -> U, S, Vᴴ\nsvd_trunc!(A, [USVᴴ]; kwargs...) -> U, S, Vᴴ\nsvd_trunc!(A, [USVᴴ], alg::AbstractAlgorithm) -> U, S, Vᴴ\n\nCompute a partial or truncated singular value decomposition (SVD) of A, such that A * (Vᴴ)' =  U * S. Here, U is an isometric matrix (orthonormal columns) of size (m, k), whereas  Vᴴ is a matrix of size (k, n) with orthonormal rows and S is a square diagonal matrix of size (k, k), with k is set by the truncation strategy.\n\nnote: Note\nThe bang method svd_trunc! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided USVᴴ as output.\n\nSee also svd_full(!), svd_compact(!) and svd_vals(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.svd_trunc!","page":"Library","title":"MatrixAlgebraKit.svd_trunc!","text":"svd_trunc(A; kwargs...) -> U, S, Vᴴ\nsvd_trunc(A, alg::AbstractAlgorithm) -> U, S, Vᴴ\nsvd_trunc!(A, [USVᴴ]; kwargs...) -> U, S, Vᴴ\nsvd_trunc!(A, [USVᴴ], alg::AbstractAlgorithm) -> U, S, Vᴴ\n\nCompute a partial or truncated singular value decomposition (SVD) of A, such that A * (Vᴴ)' =  U * S. Here, U is an isometric matrix (orthonormal columns) of size (m, k), whereas  Vᴴ is a matrix of size (k, n) with orthonormal rows and S is a square diagonal matrix of size (k, k), with k is set by the truncation strategy.\n\nnote: Note\nThe bang method svd_trunc! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided USVᴴ as output.\n\nSee also svd_full(!), svd_compact(!) and svd_vals(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.svd_vals","page":"Library","title":"MatrixAlgebraKit.svd_vals","text":"svd_vals(A; kwargs...) -> S\nsvd_vals(A, alg::AbstractAlgorithm) -> S\nsvd_vals!(A, [S]; kwargs...) -> S\nsvd_vals!(A, [S], alg::AbstractAlgorithm) -> S\n\nCompute the vector of singular values of A, such that for an M×N matrix A, S is a vector of size K = min(M, N), the number of kept singular values.\n\nSee also svd_full(!), svd_compact(!) and svd_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.svd_vals!","page":"Library","title":"MatrixAlgebraKit.svd_vals!","text":"svd_vals(A; kwargs...) -> S\nsvd_vals(A, alg::AbstractAlgorithm) -> S\nsvd_vals!(A, [S]; kwargs...) -> S\nsvd_vals!(A, [S], alg::AbstractAlgorithm) -> S\n\nCompute the vector of singular values of A, such that for an M×N matrix A, S is a vector of size K = min(M, N), the number of kept singular values.\n\nSee also svd_full(!), svd_compact(!) and svd_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.truncabove-Tuple{Any}","page":"Library","title":"MatrixAlgebraKit.truncabove","text":"truncabove(atol::Real)\n\nTruncation strategy to discard the values that are larger than atol in absolute value.\n\n\n\n\n\n","category":"method"},{"location":"library/#MatrixAlgebraKit.truncate!","page":"Library","title":"MatrixAlgebraKit.truncate!","text":"truncate!(f, out, strategy::TruncationStrategy)\n\nGeneric interface for post-truncating a decomposition, specified in out.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.truncrank","page":"Library","title":"MatrixAlgebraKit.truncrank","text":"truncrank(howmany::Int, by=abs, rev=true)\n\nTruncation strategy to keep the first howmany values when sorted according to by or the last howmany if rev is true.\n\n\n\n\n\n","category":"function"},{"location":"library/#MatrixAlgebraKit.trunctol-Tuple{Any}","page":"Library","title":"MatrixAlgebraKit.trunctol","text":"trunctol(atol::Real)\n\nTruncation strategy to discard the values that are smaller than atol in absolute value.\n\n\n\n\n\n","category":"method"},{"location":"library/#Other","page":"Library","title":"Other","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [MatrixAlgebraKit]\nOrder   = [:module, :macro]","category":"page"},{"location":"library/#MatrixAlgebraKit.@algdef-Tuple{Any}","page":"Library","title":"MatrixAlgebraKit.@algdef","text":"@algdef AlgorithmName\n\nConvenience macro to define an algorithm AlgorithmName that accepts generic keywords. This defines an exported alias for Algorithm{:AlgorithmName} along with some utility methods.\n\n\n\n\n\n","category":"macro"},{"location":"library/#MatrixAlgebraKit.@functiondef-Tuple{Any}","page":"Library","title":"MatrixAlgebraKit.@functiondef","text":"@functiondef f\n\nConvenience macro to define the boilerplate code that dispatches between several versions of f and f!. By default, this enables the following signatures to be defined in terms of the final f!(A, out, alg::Algorithm).\n\n    f(A; kwargs...)\n    f(A, alg::Algorithm)\n    f!(A, [out]; kwargs...)\n    f!(A, alg::Algorithm)\n\nSee also copy_input, select_algorithm and initialize_output.\n\n\n\n\n\n","category":"macro"},{"location":"user_interface/compositions/#Compositions","page":"Compositions","title":"Compositions","text":"","category":"section"},{"location":"user_interface/compositions/","page":"Compositions","title":"Compositions","text":"Coming soon...","category":"page"},{"location":"user_interface/truncations/","page":"Truncations","title":"Truncations","text":"CurrentModule = MatrixAlgebraKit\nCollapsedDocStrings = true","category":"page"},{"location":"user_interface/truncations/#Truncations","page":"Truncations","title":"Truncations","text":"","category":"section"},{"location":"user_interface/truncations/","page":"Truncations","title":"Truncations","text":"Currently, truncations are supported through the following different methods:","category":"page"},{"location":"user_interface/truncations/","page":"Truncations","title":"Truncations","text":"truncrank\ntrunctol\ntruncabove","category":"page"},{"location":"user_interface/truncations/#MatrixAlgebraKit.truncrank-user_interface-truncations","page":"Truncations","title":"MatrixAlgebraKit.truncrank","text":"truncrank(howmany::Int, by=abs, rev=true)\n\nTruncation strategy to keep the first howmany values when sorted according to by or the last howmany if rev is true.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/truncations/#MatrixAlgebraKit.trunctol-user_interface-truncations","page":"Truncations","title":"MatrixAlgebraKit.trunctol","text":"trunctol(atol::Real)\n\nTruncation strategy to discard the values that are smaller than atol in absolute value.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/truncations/#MatrixAlgebraKit.truncabove-user_interface-truncations","page":"Truncations","title":"MatrixAlgebraKit.truncabove","text":"truncabove(atol::Real)\n\nTruncation strategy to discard the values that are larger than atol in absolute value.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"CurrentModule = MatrixAlgebraKit\nCollapsedDocStrings = true","category":"page"},{"location":"user_interface/decompositions/#Decompositions","page":"Decompositions","title":"Decompositions","text":"","category":"section"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"A rather large class of matrix algebra methods consists of taking a single input A, and determining some factorization of that input. In order to streamline these functions, they all follow a similar common code pattern. For a given factorization f, this consists of the following methods:","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"f(A; kwargs...) -> F...\nf!(A, [F]; kwargs...) -> F...","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"Here, the input matrix is always the first argument, and optionally the output can be provided as well. The keywords are algorithm-specific, and can be used to influence the behavior of the algorithms. Importantly, for generic code patterns it is recommended to always use the output F explicitly, since some implementations may not be able to reuse the provided memory. Additionally, the f! method typically assumes that it is allowed to destroy the input A, and making use of the contents of A afterwards should be deemed as undefined behavior.","category":"page"},{"location":"user_interface/decompositions/#QR-and-LQ-Decompositions","page":"Decompositions","title":"QR and LQ Decompositions","text":"","category":"section"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"The QR decomposition transforms a matrix A into a product Q * R, where Q is orthonormal and R upper triangular. This is often used to solve linear least squares problems, or construct orthogonal bases, since it is typically less expensive than the Singular Value Decomposition. If the input A is invertible, Q and R are unique if we require the diagonal elements of R to be positive.","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"For rectangular matrices A of size (m, n), there are two modes of operation, qr_full and qr_compact. The former ensures that the resulting Q is a square unitary matrix of size (m, m), while the latter creates an isometric Q of size (m, min(m, n)).","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"Similarly, the LQ decomposition transforms a matrix A into a product L * Q, where L is lower triangular and Q orthonormal. This is equivalent to the transpose of the QR decomposition of the transpose matrix, but can be computed directly. Again there are two modes of operation, lq_full and lq_compact, with the same behavior as the QR decomposition.","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"qr_full\nqr_compact\nlq_full\nlq_compact","category":"page"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.qr_full-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.qr_full","text":"qr_full(A; kwargs...) -> Q, R\nqr_full(A, alg::AbstractAlgorithm) -> Q, R\nqr_full!(A, [QR]; kwargs...) -> Q, R\nqr_full!(A, [QR], alg::AbstractAlgorithm) -> Q, R\n\nCompute the full QR decomposition of the rectangular matrix A, such that A = Q * R where Q is a square unitary matrix with the same number of rows as A and R is an upper triangular matrix with the same size as A.\n\nnote: Note\nThe bang method qr_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided QR as output.\n\nSee also qr_compact(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.qr_compact-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.qr_compact","text":"qr_compact(A; kwargs...) -> Q, R\nqr_compact(A, alg::AbstractAlgorithm) -> Q, R\nqr_compact!(A, [QR]; kwargs...) -> Q, R\nqr_compact!(A, [QR], alg::AbstractAlgorithm) -> Q, R\n\nCompute the compact QR decomposition of the rectangular matrix A of size (m,n), such that A = Q * R where the isometric matrix Q of size (m, min(m,n)) has orthogonal columns spanning the image of A, and the matrix R of size (min(m,n), n) is upper triangular.\n\nnote: Note\nThe bang method qr_compact! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided QR as output.\n\nnote: Note\nThe compact QR decomposition is equivalent to the full QR decomposition when m >= n. Some algorithms may require m >= n.\n\nSee also qr_full(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.lq_full-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.lq_full","text":"lq_full(A; kwargs...) -> L, Q\nlq_full(A, alg::AbstractAlgorithm) -> L, Q\nlq_full!(A, [LQ]; kwargs...) -> L, Q\nlq_full!(A, [LQ], alg::AbstractAlgorithm) -> L, Q\n\nCompute the full LQ decomposition of the rectangular matrix A, such that A = L * Q where Q is a square unitary matrix with the same number of rows as A and L is a lower triangular matrix with the same size as A.\n\nnote: Note\nThe bang method lq_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided LQ as output.\n\nSee also lq_compact(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.lq_compact-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.lq_compact","text":"lq_compact(A; kwargs...) -> L, Q\nlq_compact(A, alg::AbstractAlgorithm) -> L, Q\nlq_compact!(A, [LQ]; kwargs...) -> L, Q\nlq_compact!(A, [LQ], alg::AbstractAlgorithm) -> L, Q\n\nCompute the compact LQ decomposition of the rectangular matrix A of size (m,n), such that A = L * Q where the matrix Q of size (min(m,n), n) has orthogonal rows spanning the image of A', and the matrix L of size (m, min(m,n)) is lower triangular.\n\nnote: Note\nThe bang method lq_compact! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided LQ as output.\n\nnote: Note\nThe compact QR decomposition is equivalent to the full LQ decomposition when m >= n. Some algorithms may require m <= n.\n\nSee also lq_full(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"Alongside these functions, we provide a LAPACK-based implementation for dense arrays, as provided by the following algorithm:","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"LAPACK_HouseholderQR\nLAPACK_HouseholderLQ","category":"page"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_HouseholderQR-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_HouseholderQR","text":"LAPACK_HoudeholderQR(; blocksize, positive = false, pivoted = false)\n\nAlgorithm type to denote the standard LAPACK algorithm for computing the QR decomposition of a matrix using Householder reflectors. The specific LAPACK function can be controlled using the keyword arugments, i.e.  ?geqrt will be chosen if blocksize > 1. With blocksize == 1, ?geqrf will be chosen if pivoted == false and ?geqp3 will be chosen if pivoted == true. The keyword positive =true can be used to ensure that the diagonal elements of R are non-negative.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_HouseholderLQ-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_HouseholderLQ","text":"LAPACK_HoudeholderLQ(; blocksize, positive = false)\n\nAlgorithm type to denote the standard LAPACK algorithm for computing the LQ decomposition of a matrix using Householder reflectors. The specific LAPACK function can be controlled using the keyword arugments, i.e. ?gelqt will be chosen if blocksize > 1 or ?gelqf will be chosen if blocksize == 1. The keyword positive=true can be used to ensure that the diagonal elements of L are non-negative.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#Eigenvalue-Decomposition","page":"Decompositions","title":"Eigenvalue Decomposition","text":"","category":"section"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"The Eigenvalue Decomposition transforms a square matrix A into a product V * D * V⁻¹. Equivalently, it finds V and D that satisfy A * V = V * D.","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"Not all matrices can be diagonalized, and some real matrices can only be diagonalized using complex arithmetic. In particular, the resulting decomposition can only guaranteed to be real for real symmetric inputs A. Therefore, we provide eig_ and eigh_ variants, where eig always results in complex-valued V and D, while eigh requires symmetric inputs but retains the scalartype of the input.","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"If only the eigenvalues are required, the eig_vals and eigh_vals functions can be used. These functions return the diagonal elements of D in a vector.","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"Finally, it is also possible to compute a partial or truncated eigenvalue decomposition, using the eig_trunc and eigh_trunc functions. To control the behavior of the truncation, we refer to Truncations for more information.","category":"page"},{"location":"user_interface/decompositions/#Symmetric-Eigenvalue-Decomposition","page":"Decompositions","title":"Symmetric Eigenvalue Decomposition","text":"","category":"section"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"For symmetric matrices, we provide the following functions:","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"eigh_full\neigh_trunc\neigh_vals","category":"page"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.eigh_full-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.eigh_full","text":"eigh_full(A; kwargs...) -> D, V\neigh_full(A, alg::AbstractAlgorithm) -> D, V\neigh_full!(A, [DV]; kwargs...) -> D, V\neigh_full!(A, [DV], alg::AbstractAlgorithm) -> D, V\n\nCompute the full eigenvalue decomposition of the symmetric or hermitian matrix A, such that A * V = V * D, where the unitary matrix V contains the orthogonal eigenvectors and the real diagonal matrix D contains the associated eigenvalues.\n\nnote: Note\nThe bang method eigh_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eigh_full and its variants assume additional structure on the input,\n\nand therefore will retain the eltype of the input for the eigenvalues and eigenvectors. For generic eigenvalue decompositions, see eig_full.\n\nSee also eigh_vals(!) and eigh_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.eigh_trunc-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.eigh_trunc","text":"eigh_trunc(A; kwargs...) -> D, V\neigh_trunc(A, alg::AbstractAlgorithm) -> D, V\neigh_trunc!(A, [DV]; kwargs...) -> D, V\neigh_trunc!(A, [DV], alg::AbstractAlgorithm) -> D, V\n\nCompute a partial or truncated eigenvalue decomposition of the symmetric or hermitian matrix A, such that A * V ≈ V * D, where the isometric matrix V contains a subset of the orthogonal eigenvectors and the real diagonal matrix D contains the associated eigenvalues, selected according to a truncation strategy. \n\nnote: Note\nThe bang method eigh_trunc! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eigh_full and its variants assume additional structure on the input,\n\nand therefore will retain the eltype of the input for the eigenvalues and eigenvectors. For generic eigenvalue decompositions, see eig_full.\n\nSee also eigh_full(!) and eigh_vals(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.eigh_vals-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.eigh_vals","text":"eigh_vals(A; kwargs...) -> D\neigh_vals(A, alg::AbstractAlgorithm) -> D\neigh_vals!(A, [D]; kwargs...) -> D\neigh_vals!(A, [D], alg::AbstractAlgorithm) -> D\n\nCompute the list of (real) eigenvalues of the symmetric or hermitian matrix A.\n\nnote: Note\nThe bang method eigh_vals! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eigh_full and its variants assume additional structure on the input,\n\nand therefore will retain the eltype of the input for the eigenvalues and eigenvectors. For generic eigenvalue decompositions, see eig_full.\n\nSee also eigh_full(!) and eigh_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"Alongside these functions, we provide a LAPACK-based implementation for dense arrays, as provided by the following algorithms:","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"Modules = [MatrixAlgebraKit]\nFilter = t -> t isa Type && t <: MatrixAlgebraKit.LAPACK_EighAlgorithm","category":"page"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_Bisection-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_Bisection","text":"LAPACK_Bisection()\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Bisection algorithm.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_DivideAndConquer-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_DivideAndConquer","text":"LAPACK_DivideAndConquer()\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Divide and Conquer algorithm.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_MultipleRelativelyRobustRepresentations-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_MultipleRelativelyRobustRepresentations","text":"LAPACK_MultipleRelativelyRobustRepresentations()\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix using the Multiple Relatively Robust Representations algorithm.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_QRIteration-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_QRIteration","text":"LAPACK_QRIteration()\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the QR Iteration algorithm.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#Eigenvalue-Decomposition-2","page":"Decompositions","title":"Eigenvalue Decomposition","text":"","category":"section"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"For general matrices, we provide the following functions:","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"eig_full\neig_trunc\neig_vals","category":"page"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.eig_full-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.eig_full","text":"eig_full(A; kwargs...) -> D, V\neig_full(A, alg::AbstractAlgorithm) -> D, V\neig_full!(A, [DV]; kwargs...) -> D, V\neig_full!(A, [DV], alg::AbstractAlgorithm) -> D, V\n\nCompute the full eigenvalue decomposition of the square matrix A, such that A * V = V * D, where the invertible matrix V contains the eigenvectors and the diagonal matrix D contains the associated eigenvalues.\n\nnote: Note\nThe bang method eig_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eig_full and its variants do not assume additional structure on the input,\n\nand therefore will always return complex eigenvalues and eigenvectors. For the real eigenvalue decomposition of symmetric or hermitian operators, see eigh_full.\n\nSee also eig_vals(!) and eig_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.eig_trunc-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.eig_trunc","text":"eig_trunc(A; kwargs...) -> D, V\neig_trunc(A, alg::AbstractAlgorithm) -> D, V\neig_trunc!(A, [DV]; kwargs...) -> D, V\neig_trunc!(A, [DV], alg::AbstractAlgorithm) -> D, V\n\nCompute a partial or truncated eigenvalue decomposition of the matrix A, such that A * V ≈ V * D, where the (possibly rectangular) matrix V contains  a subset of eigenvectors and the diagonal matrix D contains the associated eigenvalues, selected according to a truncation strategy.\n\nnote: Note\nThe bang method eig_trunc! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided DV as output.\n\nnote: Note\nNote that eig_full and its variants do not assume additional structure on the input,\n\nand therefore will always return complex eigenvalues and eigenvectors. For the real eigenvalue decomposition of symmetric or hermitian operators, see eigh_full.\n\nSee also eig_full(!) and eig_vals(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.eig_vals-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.eig_vals","text":"eig_vals(A; kwargs...) -> D\neig_vals(A, alg::AbstractAlgorithm) -> D\neig_vals!(A, [D]; kwargs...) -> D\neig_vals!(A, [D], alg::AbstractAlgorithm) -> D\n\nCompute the list of eigenvalues of A.\n\nnote: Note\nThe bang method eig_vals! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided D as output.\n\nnote: Note\nNote that eig_full and its variants do not assume additional structure on the input,\n\nand therefore will always return complex eigenvalues and eigenvectors. For the real eigenvalue decomposition of symmetric or hermitian operators, see eigh_full.\n\nSee also eig_full(!) and eig_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"Alongside these functions, we provide a LAPACK-based implementation for dense arrays, as provided by the following algorithms:","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"Modules = [MatrixAlgebraKit]\nFilter = t -> t isa Type && t <: MatrixAlgebraKit.LAPACK_EigAlgorithm","category":"page"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_Expert-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_Expert","text":"LAPACK_Expert()\n\nAlgorithm type to denote the expert LAPACK driver for computing the Schur or non-Hermitian eigenvalue decomposition of a matrix.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_Simple-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_Simple","text":"LAPACK_Simple()\n\nAlgorithm type to denote the simple LAPACK driver for computing the Schur or non-Hermitian eigenvalue decomposition of a matrix.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#Schur-Decomposition","page":"Decompositions","title":"Schur Decomposition","text":"","category":"section"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"The Schur decomposition transforms a complex square matrix A into a product Q * T * Qᴴ, where Q is unitary and T is upper triangular. It rewrites an arbitrary complex square matrix as unitarily similar to an upper triangular matrix whose diagonal elements are the eigenvalues of A. For real matrices, the same decomposition can be achieved with T being quasi-upper triangular, ie triangular with blocks of size (1, 1) and (2, 2) on the diagonal.","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"This decomposition is also useful for computing the eigenvalues of a matrix, which is exposed through the schur_vals function.","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"schur_full\nschur_vals","category":"page"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.schur_full-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.schur_full","text":"schur_full(A; kwargs...) -> T, Z, vals\nschur_full(A, alg::AbstractAlgorithm) -> T, Z, vals\nschur_full!(A, [TZv]; kwargs...) -> T, Z, vals\nschur_full!(A, [TZv], alg::AbstractAlgorithm) -> T, Z, vals\n\nCompute the full Schur decomposition of the square matrix A, such that A * Z = Z * T, where the orthogonal or unitary matrix Z contains the Schur vectors and the square matrix T is upper triangular (in the complex case) or quasi-upper triangular (in the real case). The list vals contains the (complex-valued) eigenvalues of A, as extracted from the (quasi-)diagonal of T.\n\nnote: Note\nThe bang method schur_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided TZv as output.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.schur_vals-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.schur_vals","text":"schur_vals(A; kwargs...) -> vals\nschur_vals(A, alg::AbstractAlgorithm) -> vals\nschur_vals!(A, [vals]; kwargs...) -> vals\nschur_vals!(A, [vals], alg::AbstractAlgorithm) -> vals\n\nCompute the list of eigenvalues of A by computing the Schur decomposition of A.\n\nnote: Note\nThe bang method schur_vals! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided vals as output.\n\nSee also eig_full(!) and eig_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"The LAPACK-based implementation for dense arrays is provided by the following algorithms:","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"Modules = [MatrixAlgebraKit]\nFilter = t -> t isa Type && t <: MatrixAlgebraKit.LAPACK_EigAlgorithm","category":"page"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_Expert-user_interface-decompositions-2","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_Expert","text":"LAPACK_Expert()\n\nAlgorithm type to denote the expert LAPACK driver for computing the Schur or non-Hermitian eigenvalue decomposition of a matrix.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_Simple-user_interface-decompositions-2","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_Simple","text":"LAPACK_Simple()\n\nAlgorithm type to denote the simple LAPACK driver for computing the Schur or non-Hermitian eigenvalue decomposition of a matrix.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#Singular-Value-Decomposition","page":"Decompositions","title":"Singular Value Decomposition","text":"","category":"section"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"The Singular Value Decomposition transforms a matrix A into a product U * Σ * Vᴴ, where U and V are orthogonal, and Σ is diagonal, real and non-negative. For a square matrix A, both U and V are unitary, and if the singular values are distinct, the decomposition is unique.","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"For rectangular matrices A of size (m, n), there are two modes of operation, svd_full and svd_compact. The former ensures that the resulting U, and V remain square unitary matrices, of size (m, m) and (n, n), with rectangular Σ of size (m, n). The latter creates an isometric U of size (m, min(m, n)), and V of size (n, min(m, n)), with a square Σ of size (min(m, n), min(m, n)).","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"It is also possible to compute the singular values only, using the svd_vals function. This then returns a vector of the values on the diagonal of Σ.","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"Finally, we also support computing a partial or truncated SVD, using the svd_trunc function.","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"svd_full\nsvd_compact\nsvd_vals\nsvd_trunc","category":"page"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.svd_full-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.svd_full","text":"svd_full(A; kwargs...) -> U, S, Vᴴ\nsvd_full(A, alg::AbstractAlgorithm) -> U, S, Vᴴ\nsvd_full!(A, [USVᴴ]; kwargs...) -> U, S, Vᴴ\nsvd_full!(A, [USVᴴ], alg::AbstractAlgorithm) -> U, S, Vᴴ\n\nCompute the full singular value decomposition (SVD) of the rectangular matrix A of size (m, n), such that A = U * S * Vᴴ. Here, U and Vᴴ are unitary matrices of size (m, m) and (n, n) respectively, and S is a diagonal matrix of size (m, n).\n\nnote: Note\nThe bang method svd_full! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided USVᴴ as output.\n\nSee also svd_compact(!), svd_vals(!) and svd_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.svd_compact-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.svd_compact","text":"svd_compact(A; kwargs...) -> U, S, Vᴴ\nsvd_compact(A, alg::AbstractAlgorithm) -> U, S, Vᴴ\nsvd_compact!(A, [USVᴴ]; kwargs...) -> U, S, Vᴴ\nsvd_compact!(A, [USVᴴ], alg::AbstractAlgorithm) -> U, S, Vᴴ\n\nCompute the compact singular value decomposition (SVD) of the rectangular matrix A of size (m, n), such that A = U * S * Vᴴ. Here, U is an isometric matrix (orthonormal columns) of size (m, k), whereas  Vᴴ is a matrix of size (k, n) with orthonormal rows and S is a square diagonal matrix of size (k, k), with k = min(m, n).\n\nnote: Note\nThe bang method svd_compact! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided USVᴴ as output.\n\nSee also svd_full(!), svd_vals(!) and svd_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.svd_vals-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.svd_vals","text":"svd_vals(A; kwargs...) -> S\nsvd_vals(A, alg::AbstractAlgorithm) -> S\nsvd_vals!(A, [S]; kwargs...) -> S\nsvd_vals!(A, [S], alg::AbstractAlgorithm) -> S\n\nCompute the vector of singular values of A, such that for an M×N matrix A, S is a vector of size K = min(M, N), the number of kept singular values.\n\nSee also svd_full(!), svd_compact(!) and svd_trunc(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.svd_trunc-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.svd_trunc","text":"svd_trunc(A; kwargs...) -> U, S, Vᴴ\nsvd_trunc(A, alg::AbstractAlgorithm) -> U, S, Vᴴ\nsvd_trunc!(A, [USVᴴ]; kwargs...) -> U, S, Vᴴ\nsvd_trunc!(A, [USVᴴ], alg::AbstractAlgorithm) -> U, S, Vᴴ\n\nCompute a partial or truncated singular value decomposition (SVD) of A, such that A * (Vᴴ)' =  U * S. Here, U is an isometric matrix (orthonormal columns) of size (m, k), whereas  Vᴴ is a matrix of size (k, n) with orthonormal rows and S is a square diagonal matrix of size (k, k), with k is set by the truncation strategy.\n\nnote: Note\nThe bang method svd_trunc! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided USVᴴ as output.\n\nSee also svd_full(!), svd_compact(!) and svd_vals(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"MatrixAlgebraKit again ships with LAPACK-based implementations for dense arrays:","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"Modules = [MatrixAlgebraKit]\nFilter = t -> t isa Type && t <: MatrixAlgebraKit.LAPACK_SVDAlgorithm","category":"page"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_Bisection-user_interface-decompositions-2","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_Bisection","text":"LAPACK_Bisection()\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Bisection algorithm.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_DivideAndConquer-user_interface-decompositions-2","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_DivideAndConquer","text":"LAPACK_DivideAndConquer()\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Divide and Conquer algorithm.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_Jacobi-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_Jacobi","text":"LAPACK_Jacobi()\n\nAlgorithm type to denote the LAPACK driver for computing the singular value decomposition of a general matrix using the Jacobi algorithm.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.LAPACK_QRIteration-user_interface-decompositions-2","page":"Decompositions","title":"MatrixAlgebraKit.LAPACK_QRIteration","text":"LAPACK_QRIteration()\n\nAlgorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the QR Iteration algorithm.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#Polar-Decomposition","page":"Decompositions","title":"Polar Decomposition","text":"","category":"section"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"The Polar Decomposition of a matrix A is a factorization A = W * P, where W is unitary and P is positive semi-definite. If A is invertible (and therefore square), the polar decomposition always exists and is unique. For non-square matrices, the polar decomposition is not unique, but P is. In particular, the polar decomposition is unique if A is full rank.","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"This decomposition can be computed for both sides, resulting in the left_polar and right_polar functions.","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"left_polar\nright_polar","category":"page"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.left_polar-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.left_polar","text":"left_polar(A; kwargs...) -> W, P\nleft_polar(A, alg::AbstractAlgorithm) -> W, P\nleft_polar!(A, [WP]; kwargs...) -> W, P\nleft_polar!(A, [WP], alg::AbstractAlgorithm) -> W, P\n\nCompute the full polar decomposition of the rectangular matrix A of size (m, n) with m >= n, such that A = W * P. Here, W is an isometric matrix (orthonormal columns) of size (m, n), whereas P is a positive (semi)definite matrix of size (n, n).\n\nnote: Note\nThe bang method left_polar! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided WP as output.\n\nSee also right_polar(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.right_polar-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.right_polar","text":"right_polar(A; kwargs...) -> P, Wᴴ\nright_polar(A, alg::AbstractAlgorithm) -> P, Wᴴ\nright_polar!(A, [PWᴴ]; kwargs...) -> P, Wᴴ\nright_polar!(A, [PWᴴ], alg::AbstractAlgorithm) -> P, Wᴴ\n\nCompute the full polar decomposition of the rectangular matrix A of size (m, n) with n >= m, such that A = P * Wᴴ. Here, P is a positive (semi)definite matrix of size (m, m), whereas Wᴴ is a matrix with orthonormal rows (its adjoint is isometric) of size (n, m).\n\nnote: Note\nThe bang method right_polar! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided WP as output.\n\nSee also left_polar(!).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"These functions are implemented by first computing a singular value decomposition, and then constructing the polar decomposition from the singular values and vectors. Therefore, the relevant LAPACK-based implementation is the one for the SVD:","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"PolarViaSVD","category":"page"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.PolarViaSVD-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.PolarViaSVD","text":"PolarViaSVD(svdalg)\n\nAlgorithm for computing the polar decomposition of a matrix A via the singular value decomposition (SVD) of A. The svdalg argument specifies the SVD algorithm to use.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/decompositions/#Orthogonal-Subspaces","page":"Decompositions","title":"Orthogonal Subspaces","text":"","category":"section"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"Often it is useful to compute orthogonal bases for a particular subspace defined by a matrix. Given a matrix A we can compute an orthonormal basis for its image or coimage, and factorize the matrix accordingly. These bases are accessible through left_orth and right_orth respectively. This is implemented through a combination of the decompositions mentioned above, and serves as a convenient interface to these operations.","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"left_orth\nright_orth","category":"page"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.left_orth-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.left_orth","text":"left_orth(A; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -> V, C\nleft_orth!(A, [VC]; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -> V, C\n\nCompute an orthonormal basis V for the image of the matrix A of size (m, n), as well as a  matrix C (the corestriction) such that A factors as A = V * C. The keyword argument kind can be used to specify the specific orthogonal decomposition that should be used to factor A, whereas atol and rtol can be used to control the precision in determining the rank of A via its singular values.\n\nThis is a high-level wrapper and will use one of the decompositions qr!, svd!, and left_polar! to compute the orthogonal basis V, as controlled by the keyword arguments.\n\nWhen kind is provided, its possible values are\n\nkind == :qrpos: V and C are computed using the positive QR decomposition.   This requires iszero(atol) && iszero(rtol) and left_orth!(A, [VC]) is equivalent to   qr_compact!(A, [VC], alg) with a default value alg = select_algorithm(qr_compact!, A; positive=true)\nkind == :qr: V and C are computed using the QR decomposition,   This requires iszero(atol) && iszero(rtol) and left_orth!(A, [VC]) is equivalent to   qr_compact!(A, [VC], alg) with a default value alg = select_algorithm(qr_compact!, A)\nkind == :polar: V and C are computed using the polar decomposition,   This requires iszero(atol) && iszero(rtol) and left_orth!(A, [VC]) is equivalent to   left_polar!(A, [VC], alg) with a default value alg = select_algorithm(left_polar!, A)\nkind == :svd: V and C are computed using the singular value decomposition svd_trunc!,   where V will contain the left singular vectors corresponding to the singular values that   are larger than max(atol, rtol * σ₁), where σ₁ is the largest singular value of A.   C is computed as the product of the singular values and the right singular vectors,   i.e. with U, S, Vᴴ = svd_trunc!(A), we have V = U and C = S * Vᴴ.\n\nWhen kind is not provided, the default value is :qrpos when iszero(atol) && iszero(rtol) and :svd otherwise. Finally, finer control is obtained by providing an explicit algorithm using the alg keyword argument, which should be compatible with the chosen or default value of kind.\n\nnote: Note\nThe bang method left_orth! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided CV as output.\n\nSee also right_orth(!), left_orth(!), right_orth(!)\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.right_orth-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.right_orth","text":"right_orth(A; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -> C, Vᴴ\nright_orth!(A, [CVᴴ]; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -> C, Vᴴ\n\nCompute an orthonormal basis V = adjoint(Vᴴ) for the coimage of the matrix A, i.e. for the image of adjoint(A), as well as a matrix C such that A = C * Vᴴ. The keyword argument kind can be used to specify the specific orthogonal decomposition that should be used to factor A, whereas atol and rtol can be used to control the precision in determining the rank of A via its singular values.\n\nThis is a high-level wrapper and will use call one of the decompositions qr!, svd!, and left_polar! to compute the orthogonal basis V, as controlled by the keyword arguments.\n\nWhen kind is provided, its possible values are\n\nkind == :lqpos: C and Vᴴ are computed using the positive QR decomposition.   This requires iszero(atol) && iszero(rtol) and right_orth!(A, [CVᴴ]) is equivalent to   lq_compact!(A, [CVᴴ], alg) with a default value alg = select_algorithm(lq_compact!, A; positive=true)\nkind == :lq: C and Vᴴ are computed using the QR decomposition,   This requires iszero(atol) && iszero(rtol) and right_orth!(A, [CVᴴ]) is equivalent to   lq_compact!(A, [CVᴴ], alg) with a default value alg = select_algorithm(lq_compact!, A))\nkind == :polar: C and Vᴴ are computed using the polar decomposition,   This requires iszero(atol) && iszero(rtol) and right_orth!(A, [CVᴴ]) is equivalent to   right_polar!(A, [CVᴴ], alg) with a default value alg = select_algorithm(right_polar!, A))\nkind == :svd: C and Vᴴ are computed using the singular value decomposition svd_trunc!,   where V = adjoint(Vᴴ) will contain the right singular vectors corresponding to the singular   values that are larger than max(atol, rtol * σ₁), where σ₁ is the largest singular value of A.   C is computed as the product of the singular values and the right singular vectors,   i.e. with U, S, Vᴴ = svd_trunc!(A), we have C = rmul!(U, S) and Vᴴ = Vᴴ.\n\nWhen kind is not provided, the default value is :lqpos when iszero(atol) && iszero(rtol) and :svd otherwise. Finally, finer control is obtained by providing an explicit algorithm using the alg keyword argument, which should be compatible with the chosen or default value of kind.\n\nnote: Note\nThe bang method right_orth! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided CVᴴ as output.\n\nSee also left_orth(!), left_orth(!), right_orth(!)\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#Null-Spaces","page":"Decompositions","title":"Null Spaces","text":"","category":"section"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"Similarly, it can be convenient to obtain an orthogonal basis for the kernel or cokernel of a matrix. These are the compliments of the image and coimage, and can be computed using the left_null and right_null functions. Again, this is typically implemented through a combination of the decompositions mentioned above, and serves as a convenient interface to these operations.","category":"page"},{"location":"user_interface/decompositions/","page":"Decompositions","title":"Decompositions","text":"left_null\nright_null","category":"page"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.left_null-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.left_null","text":"left_null(A; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -> N\nleft_null!(A, [N]; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -> N\n\nCompute an orthonormal basis N for the cokernel of the matrix A of size (m, n), i.e. the nullspace of adjoint(A), such that adjoint(A)*N ≈ 0 and N'*N ≈ I. The keyword argument kind can be used to specify the specific orthogonal decomposition that should be used to factor A, whereas atol and rtol can be used to control the precision in determining the rank of A via its singular values.\n\nThis is a high-level wrapper and will use one of the decompositions qr! or svd! to compute the orthogonal basis N, as controlled by the keyword arguments.\n\nWhen kind is provided, its possible values are\n\nkind == :qrpos: N is computed using the positive QR decomposition.   This requires iszero(atol) && iszero(rtol) and left_null!(A, [N], kind=:qrpos) is equivalent to   qr_null!(A, [N], alg) with a default value alg = select_algorithm(qr_compact!, A; positive=true)\nkind == :qr: N is computed using the (nonpositive) QR decomposition.   This requires iszero(atol) && iszero(rtol) and left_null!(A, [N], kind=:qr) is equivalent to   qr_null!(A, [N], alg) with a default value alg = select_algorithm(qr_compact!, A)\nkind == :svd: N is computed using the singular value decomposition and will contain    the left singular vectors corresponding to the singular values that   are smaller than max(atol, rtol * σ₁), where σ₁ is the largest singular value of A.\n\nWhen kind is not provided, the default value is :qrpos when iszero(atol) && iszero(rtol) and :svd otherwise. Finally, finer control is obtained by providing an explicit algorithm using the alg keyword argument, which should be compatible with the chosen or default value of kind.\n\nnote: Note\nThe bang method left_null! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided N as output.\n\nSee also right_null(!), left_orth(!), right_orth(!)\n\n\n\n\n\n","category":"function"},{"location":"user_interface/decompositions/#MatrixAlgebraKit.right_null-user_interface-decompositions","page":"Decompositions","title":"MatrixAlgebraKit.right_null","text":"right_null(A; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -> Nᴴ\nright_null!(A, [Nᴴ]; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -> Nᴴ\n\nCompute an orthonormal basis N = adjoint(Nᴴ) for the kernel or nullspace of the matrix A of size (m, n), such that A*adjoint(Nᴴ) ≈ 0 and Nᴴ*adjoint(Nᴴ) ≈ I. The keyword argument kind can be used to specify the specific orthogonal decomposition that should be used to factor A, whereas atol and rtol can be used to control the precision in determining the rank of A via its singular values.\n\nThis is a high-level wrapper and will use one of the decompositions lq! or svd! to compute the orthogonal basis Nᴴ, as controlled by the keyword arguments.\n\nWhen kind is provided, its possible values are\n\nkind == :lqpos: Nᴴ is computed using the positive LQ decomposition.   This requires iszero(atol) && iszero(rtol) and right_null!(A, [Nᴴ], kind=:lqpos) is equivalent to   lq_null!(A, [Nᴴ], alg) with a default value alg = select_algorithm(lq_compact!, A; positive=true)\nkind == :lq: Nᴴ is computed using the (nonpositive) LQ decomposition.   This requires iszero(atol) && iszero(rtol) and right_null!(A, [Nᴴ], kind=:lq) is equivalent to   lq_null!(A, [Nᴴ], alg) with a default value alg = select_algorithm(lq_compact!, A)\nkind == :svd: N is computed using the singular value decomposition and will contain    the left singular vectors corresponding to the singular values that   are smaller than max(atol, rtol * σ₁), where σ₁ is the largest singular value of A.\n\nWhen kind is not provided, the default value is :lqpos when iszero(atol) && iszero(rtol) and :svd otherwise. Finally, finer control is obtained by providing an explicit algorithm using the alg keyword argument, which should be compatible with the chosen or default value of kind.\n\nnote: Note\nThe bang method right_null! optionally accepts the output structure and possibly destroys the input matrix A. Always use the return value of the function as it may not always be possible to use the provided Nᴴ as output.\n\nSee also left_null(!), left_orth(!), right_orth(!)\n\n\n\n\n\n","category":"function"},{"location":"#MatrixAlgebraKit.jl","page":"Home","title":"MatrixAlgebraKit.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia interface for matrix algebra, with a focus on performance, flexibility and extensibility.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MatrixAlgebraKit.jl is part of the general registry, and can be installed through the package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add MatrixAlgebraKit","category":"page"},{"location":"#Key-features","page":"Home","title":"Key features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The main goals of this package are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Definition of a common interface that is sufficiently expressive to allow easy adoption and extension.\nAbility to pass pre-allocated output arrays where the result of a computation is stored.\nAbility to easily switch between different backends and algorithms for the same operation.\nFirst class availability of pullback rules that can be used in combination with different AD ecosystems.","category":"page"},{"location":"#User-Interface","page":"Home","title":"User Interface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"On the user-facing side of this package, we provide various implementations and interfaces for different matrix algebra operations. These operations typically follow some common skeleton, and here we go into a little more detail to what behavior can be expected.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"user_interface/compositions.md\", \"user_interface/decompositions.md\",\n         \"user_interface/truncations.md\", \"user_interface/matrix_functions.md\"]\nDepth = 2","category":"page"}]
}
