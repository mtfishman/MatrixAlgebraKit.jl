<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Decompositions · MatrixAlgebraKit.jl</title><meta name="title" content="Decompositions · MatrixAlgebraKit.jl"/><meta property="og:title" content="Decompositions · MatrixAlgebraKit.jl"/><meta property="twitter:title" content="Decompositions · MatrixAlgebraKit.jl"/><meta name="description" content="Documentation for MatrixAlgebraKit.jl."/><meta property="og:description" content="Documentation for MatrixAlgebraKit.jl."/><meta property="twitter:description" content="Documentation for MatrixAlgebraKit.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MatrixAlgebraKit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">User Interface</span><ul><li><a class="tocitem" href="../compositions/">Compositions</a></li><li class="is-active"><a class="tocitem" href>Decompositions</a><ul class="internal"><li><a class="tocitem" href="#QR-and-LQ-Decompositions"><span>QR and LQ Decompositions</span></a></li><li><a class="tocitem" href="#Eigenvalue-Decomposition"><span>Eigenvalue Decomposition</span></a></li><li><a class="tocitem" href="#Schur-Decomposition"><span>Schur Decomposition</span></a></li><li><a class="tocitem" href="#Singular-Value-Decomposition"><span>Singular Value Decomposition</span></a></li><li><a class="tocitem" href="#Polar-Decomposition"><span>Polar Decomposition</span></a></li><li><a class="tocitem" href="#Orthogonal-Subspaces"><span>Orthogonal Subspaces</span></a></li><li><a class="tocitem" href="#Null-Spaces"><span>Null Spaces</span></a></li></ul></li><li><a class="tocitem" href="../truncations/">Truncations</a></li><li><a class="tocitem" href="../matrix_functions/">Matrix functions</a></li></ul></li><li><a class="tocitem" href="../../dev_interface/">Developer Interface</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Interface</a></li><li class="is-active"><a href>Decompositions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Decompositions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/main/docs/src/user_interface/decompositions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Decompositions"><a class="docs-heading-anchor" href="#Decompositions">Decompositions</a><a id="Decompositions-1"></a><a class="docs-heading-anchor-permalink" href="#Decompositions" title="Permalink"></a></h1><p>A rather large class of matrix algebra methods consists of taking a single input <code>A</code>, and determining some factorization of that input. In order to streamline these functions, they all follow a similar common code pattern. For a given factorization <code>f</code>, this consists of the following methods:</p><pre><code class="language-julia hljs">f(A; kwargs...) -&gt; F...
f!(A, [F]; kwargs...) -&gt; F...</code></pre><p>Here, the input matrix is always the first argument, and optionally the output can be provided as well. The keywords are algorithm-specific, and can be used to influence the behavior of the algorithms. Importantly, for generic code patterns it is recommended to always use the output <code>F</code> explicitly, since some implementations may not be able to reuse the provided memory. Additionally, the <code>f!</code> method typically assumes that it is allowed to destroy the input <code>A</code>, and making use of the contents of <code>A</code> afterwards should be deemed as undefined behavior.</p><h2 id="QR-and-LQ-Decompositions"><a class="docs-heading-anchor" href="#QR-and-LQ-Decompositions">QR and LQ Decompositions</a><a id="QR-and-LQ-Decompositions-1"></a><a class="docs-heading-anchor-permalink" href="#QR-and-LQ-Decompositions" title="Permalink"></a></h2><p>The <a href="https://en.wikipedia.org/wiki/QR_decomposition">QR decomposition</a> transforms a matrix <code>A</code> into a product <code>Q * R</code>, where <code>Q</code> is orthonormal and <code>R</code> upper triangular. This is often used to solve linear least squares problems, or construct orthogonal bases, since it is typically less expensive than the <a href="#Singular-Value-Decomposition">Singular Value Decomposition</a>. If the input <code>A</code> is invertible, <code>Q</code> and <code>R</code> are unique if we require the diagonal elements of <code>R</code> to be positive.</p><p>For rectangular matrices <code>A</code> of size <code>(m, n)</code>, there are two modes of operation, <a href="../../library/#MatrixAlgebraKit.qr_full"><code>qr_full</code></a> and <a href="../../library/#MatrixAlgebraKit.qr_compact"><code>qr_compact</code></a>. The former ensures that the resulting <code>Q</code> is a square unitary matrix of size <code>(m, m)</code>, while the latter creates an isometric <code>Q</code> of size <code>(m, min(m, n))</code>.</p><p>Similarly, the <a href="https://en.wikipedia.org/wiki/LQ_decomposition">LQ decomposition</a> transforms a matrix <code>A</code> into a product <code>L * Q</code>, where <code>L</code> is lower triangular and <code>Q</code> orthonormal. This is equivalent to the <em>transpose</em> of the QR decomposition of the <em>transpose</em> matrix, but can be computed directly. Again there are two modes of operation, <a href="../../library/#MatrixAlgebraKit.lq_full"><code>lq_full</code></a> and <a href="../../library/#MatrixAlgebraKit.lq_compact"><code>lq_compact</code></a>, with the same behavior as the QR decomposition.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.qr_full-user_interface-decompositions" href="#MatrixAlgebraKit.qr_full-user_interface-decompositions"><code>MatrixAlgebraKit.qr_full</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qr_full(A; kwargs...) -&gt; Q, R
qr_full(A, alg::AbstractAlgorithm) -&gt; Q, R
qr_full!(A, [QR]; kwargs...) -&gt; Q, R
qr_full!(A, [QR], alg::AbstractAlgorithm) -&gt; Q, R</code></pre><p>Compute the full QR decomposition of the rectangular matrix <code>A</code>, such that <code>A = Q * R</code> where <code>Q</code> is a square unitary matrix with the same number of rows as <code>A</code> and <code>R</code> is an upper triangular matrix with the same size as <code>A</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>qr_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>QR</code> as output.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.qr_compact"><code>qr_compact(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/interface/qr.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.qr_compact-user_interface-decompositions" href="#MatrixAlgebraKit.qr_compact-user_interface-decompositions"><code>MatrixAlgebraKit.qr_compact</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qr_compact(A; kwargs...) -&gt; Q, R
qr_compact(A, alg::AbstractAlgorithm) -&gt; Q, R
qr_compact!(A, [QR]; kwargs...) -&gt; Q, R
qr_compact!(A, [QR], alg::AbstractAlgorithm) -&gt; Q, R</code></pre><p>Compute the compact QR decomposition of the rectangular matrix <code>A</code> of size <code>(m,n)</code>, such that <code>A = Q * R</code> where the isometric matrix <code>Q</code> of size <code>(m, min(m,n))</code> has orthogonal columns spanning the image of <code>A</code>, and the matrix <code>R</code> of size <code>(min(m,n), n)</code> is upper triangular.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>qr_compact!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>QR</code> as output.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The compact QR decomposition is equivalent to the full QR decomposition when <code>m &gt;= n</code>. Some algorithms may require <code>m &gt;= n</code>.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.qr_full"><code>qr_full(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/interface/qr.jl#L22-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.lq_full-user_interface-decompositions" href="#MatrixAlgebraKit.lq_full-user_interface-decompositions"><code>MatrixAlgebraKit.lq_full</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lq_full(A; kwargs...) -&gt; L, Q
lq_full(A, alg::AbstractAlgorithm) -&gt; L, Q
lq_full!(A, [LQ]; kwargs...) -&gt; L, Q
lq_full!(A, [LQ], alg::AbstractAlgorithm) -&gt; L, Q</code></pre><p>Compute the full LQ decomposition of the rectangular matrix <code>A</code>, such that <code>A = L * Q</code> where <code>Q</code> is a square unitary matrix with the same number of rows as <code>A</code> and <code>L</code> is a lower triangular matrix with the same size as <code>A</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>lq_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>LQ</code> as output.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.lq_compact"><code>lq_compact(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/interface/lq.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.lq_compact-user_interface-decompositions" href="#MatrixAlgebraKit.lq_compact-user_interface-decompositions"><code>MatrixAlgebraKit.lq_compact</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lq_compact(A; kwargs...) -&gt; L, Q
lq_compact(A, alg::AbstractAlgorithm) -&gt; L, Q
lq_compact!(A, [LQ]; kwargs...) -&gt; L, Q
lq_compact!(A, [LQ], alg::AbstractAlgorithm) -&gt; L, Q</code></pre><p>Compute the compact LQ decomposition of the rectangular matrix <code>A</code> of size <code>(m,n)</code>, such that <code>A = L * Q</code> where the matrix <code>Q</code> of size <code>(min(m,n), n)</code> has orthogonal rows spanning the image of <code>A&#39;</code>, and the matrix <code>L</code> of size <code>(m, min(m,n))</code> is lower triangular.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>lq_compact!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>LQ</code> as output.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The compact QR decomposition is equivalent to the full LQ decomposition when <code>m &gt;= n</code>. Some algorithms may require <code>m &lt;= n</code>.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.lq_full"><code>lq_full(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/interface/lq.jl#L22-L42">source</a></section></article><p>Alongside these functions, we provide a LAPACK-based implementation for dense arrays, as provided by the following algorithm:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_HouseholderQR-user_interface-decompositions" href="#MatrixAlgebraKit.LAPACK_HouseholderQR-user_interface-decompositions"><code>MatrixAlgebraKit.LAPACK_HouseholderQR</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_HoudeholderQR(; blocksize, positive = false, pivoted = false)</code></pre><p>Algorithm type to denote the standard LAPACK algorithm for computing the QR decomposition of a matrix using Householder reflectors. The specific LAPACK function can be controlled using the keyword arugments, i.e.  <code>?geqrt</code> will be chosen if <code>blocksize &gt; 1</code>. With <code>blocksize == 1</code>, <code>?geqrf</code> will be chosen if <code>pivoted == false</code> and <code>?geqp3</code> will be chosen if <code>pivoted == true</code>. The keyword <code>positive =true</code> can be used to ensure that the diagonal elements of <code>R</code> are non-negative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/implementations/decompositions.jl#L12-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_HouseholderLQ-user_interface-decompositions" href="#MatrixAlgebraKit.LAPACK_HouseholderLQ-user_interface-decompositions"><code>MatrixAlgebraKit.LAPACK_HouseholderLQ</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_HoudeholderLQ(; blocksize, positive = false)</code></pre><p>Algorithm type to denote the standard LAPACK algorithm for computing the LQ decomposition of a matrix using Householder reflectors. The specific LAPACK function can be controlled using the keyword arugments, i.e. <code>?gelqt</code> will be chosen if <code>blocksize &gt; 1</code> or <code>?gelqf</code> will be chosen if <code>blocksize == 1</code>. The keyword <code>positive=true</code> can be used to ensure that the diagonal elements of <code>L</code> are non-negative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/implementations/decompositions.jl#L24-L32">source</a></section></article><h2 id="Eigenvalue-Decomposition"><a class="docs-heading-anchor" href="#Eigenvalue-Decomposition">Eigenvalue Decomposition</a><a id="Eigenvalue-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Eigenvalue-Decomposition" title="Permalink"></a></h2><p>The <a href="https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix">Eigenvalue Decomposition</a> transforms a square matrix <code>A</code> into a product <code>V * D * V⁻¹</code>. Equivalently, it finds <code>V</code> and <code>D</code> that satisfy <code>A * V = V * D</code>.</p><p>Not all matrices can be diagonalized, and some real matrices can only be diagonalized using complex arithmetic. In particular, the resulting decomposition can only guaranteed to be real for real symmetric inputs <code>A</code>. Therefore, we provide <code>eig_</code> and <code>eigh_</code> variants, where <code>eig</code> always results in complex-valued <code>V</code> and <code>D</code>, while <code>eigh</code> requires symmetric inputs but retains the scalartype of the input.</p><p>If only the eigenvalues are required, the <a href="../../library/#MatrixAlgebraKit.eig_vals"><code>eig_vals</code></a> and <a href="../../library/#MatrixAlgebraKit.eigh_vals"><code>eigh_vals</code></a> functions can be used. These functions return the diagonal elements of <code>D</code> in a vector.</p><p>Finally, it is also possible to compute a partial or truncated eigenvalue decomposition, using the <a href="../../library/#MatrixAlgebraKit.eig_trunc"><code>eig_trunc</code></a> and <a href="../../library/#MatrixAlgebraKit.eigh_trunc"><code>eigh_trunc</code></a> functions. To control the behavior of the truncation, we refer to <a href="../truncations/#Truncations">Truncations</a> for more information.</p><h3 id="Symmetric-Eigenvalue-Decomposition"><a class="docs-heading-anchor" href="#Symmetric-Eigenvalue-Decomposition">Symmetric Eigenvalue Decomposition</a><a id="Symmetric-Eigenvalue-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Symmetric-Eigenvalue-Decomposition" title="Permalink"></a></h3><p>For symmetric matrices, we provide the following functions:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.eigh_full-user_interface-decompositions" href="#MatrixAlgebraKit.eigh_full-user_interface-decompositions"><code>MatrixAlgebraKit.eigh_full</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eigh_full(A; kwargs...) -&gt; D, V
eigh_full(A, alg::AbstractAlgorithm) -&gt; D, V
eigh_full!(A, [DV]; kwargs...) -&gt; D, V
eigh_full!(A, [DV], alg::AbstractAlgorithm) -&gt; D, V</code></pre><p>Compute the full eigenvalue decomposition of the symmetric or hermitian matrix <code>A</code>, such that <code>A * V = V * D</code>, where the unitary matrix <code>V</code> contains the orthogonal eigenvectors and the real diagonal matrix <code>D</code> contains the associated eigenvalues.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>eigh_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note that <a href="../../library/#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a> and its variants assume additional structure on the input,</p></div></div><p>and therefore will retain the <code>eltype</code> of the input for the eigenvalues and eigenvectors. For generic eigenvalue decompositions, see <a href="../../library/#MatrixAlgebraKit.eig_full"><code>eig_full</code></a>.</p><p>See also <a href="../../library/#MatrixAlgebraKit.eigh_vals"><code>eigh_vals(!)</code></a> and <a href="../../library/#MatrixAlgebraKit.eigh_trunc"><code>eigh_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/interface/eigh.jl#L22-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.eigh_trunc-user_interface-decompositions" href="#MatrixAlgebraKit.eigh_trunc-user_interface-decompositions"><code>MatrixAlgebraKit.eigh_trunc</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eigh_trunc(A; kwargs...) -&gt; D, V
eigh_trunc(A, alg::AbstractAlgorithm) -&gt; D, V
eigh_trunc!(A, [DV]; kwargs...) -&gt; D, V
eigh_trunc!(A, [DV], alg::AbstractAlgorithm) -&gt; D, V</code></pre><p>Compute a partial or truncated eigenvalue decomposition of the symmetric or hermitian matrix <code>A</code>, such that <code>A * V ≈ V * D</code>, where the isometric matrix <code>V</code> contains a subset of the orthogonal eigenvectors and the real diagonal matrix <code>D</code> contains the associated eigenvalues, selected according to a truncation strategy. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>eigh_trunc!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note that <a href="../../library/#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a> and its variants assume additional structure on the input,</p></div></div><p>and therefore will retain the <code>eltype</code> of the input for the eigenvalues and eigenvectors. For generic eigenvalue decompositions, see <a href="../../library/#MatrixAlgebraKit.eig_full"><code>eig_full</code></a>.</p><p>See also <a href="../../library/#MatrixAlgebraKit.eigh_full"><code>eigh_full(!)</code></a> and <a href="../../library/#MatrixAlgebraKit.eigh_vals"><code>eigh_vals(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/interface/eigh.jl#L44-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.eigh_vals-user_interface-decompositions" href="#MatrixAlgebraKit.eigh_vals-user_interface-decompositions"><code>MatrixAlgebraKit.eigh_vals</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eigh_vals(A; kwargs...) -&gt; D
eigh_vals(A, alg::AbstractAlgorithm) -&gt; D
eigh_vals!(A, [D]; kwargs...) -&gt; D
eigh_vals!(A, [D], alg::AbstractAlgorithm) -&gt; D</code></pre><p>Compute the list of (real) eigenvalues of the symmetric or hermitian matrix <code>A</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>eigh_vals!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note that <a href="../../library/#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a> and its variants assume additional structure on the input,</p></div></div><p>and therefore will retain the <code>eltype</code> of the input for the eigenvalues and eigenvectors. For generic eigenvalue decompositions, see <a href="../../library/#MatrixAlgebraKit.eig_full"><code>eig_full</code></a>.</p><p>See also <a href="../../library/#MatrixAlgebraKit.eigh_full"><code>eigh_full(!)</code></a> and <a href="../../library/#MatrixAlgebraKit.eigh_trunc"><code>eigh_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/interface/eigh.jl#L67-L84">source</a></section></article><p>Alongside these functions, we provide a LAPACK-based implementation for dense arrays, as provided by the following algorithms:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_Bisection-user_interface-decompositions" href="#MatrixAlgebraKit.LAPACK_Bisection-user_interface-decompositions"><code>MatrixAlgebraKit.LAPACK_Bisection</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_Bisection()</code></pre><p>Algorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Bisection algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/implementations/decompositions.jl#L70-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_DivideAndConquer-user_interface-decompositions" href="#MatrixAlgebraKit.LAPACK_DivideAndConquer-user_interface-decompositions"><code>MatrixAlgebraKit.LAPACK_DivideAndConquer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_DivideAndConquer()</code></pre><p>Algorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Divide and Conquer algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/implementations/decompositions.jl#L79-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_MultipleRelativelyRobustRepresentations-user_interface-decompositions" href="#MatrixAlgebraKit.LAPACK_MultipleRelativelyRobustRepresentations-user_interface-decompositions"><code>MatrixAlgebraKit.LAPACK_MultipleRelativelyRobustRepresentations</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_MultipleRelativelyRobustRepresentations()</code></pre><p>Algorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix using the Multiple Relatively Robust Representations algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/implementations/decompositions.jl#L88-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_QRIteration-user_interface-decompositions" href="#MatrixAlgebraKit.LAPACK_QRIteration-user_interface-decompositions"><code>MatrixAlgebraKit.LAPACK_QRIteration</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_QRIteration()</code></pre><p>Algorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the QR Iteration algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/implementations/decompositions.jl#L61-L67">source</a></section></article><h3 id="Eigenvalue-Decomposition-2"><a class="docs-heading-anchor" href="#Eigenvalue-Decomposition-2">Eigenvalue Decomposition</a><a class="docs-heading-anchor-permalink" href="#Eigenvalue-Decomposition-2" title="Permalink"></a></h3><p>For general matrices, we provide the following functions:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.eig_full-user_interface-decompositions" href="#MatrixAlgebraKit.eig_full-user_interface-decompositions"><code>MatrixAlgebraKit.eig_full</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eig_full(A; kwargs...) -&gt; D, V
eig_full(A, alg::AbstractAlgorithm) -&gt; D, V
eig_full!(A, [DV]; kwargs...) -&gt; D, V
eig_full!(A, [DV], alg::AbstractAlgorithm) -&gt; D, V</code></pre><p>Compute the full eigenvalue decomposition of the square matrix <code>A</code>, such that <code>A * V = V * D</code>, where the invertible matrix <code>V</code> contains the eigenvectors and the diagonal matrix <code>D</code> contains the associated eigenvalues.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>eig_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note that <a href="../../library/#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and its variants do not assume additional structure on the input,</p></div></div><p>and therefore will always return complex eigenvalues and eigenvectors. For the real eigenvalue decomposition of symmetric or hermitian operators, see <a href="../../library/#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a>.</p><p>See also <a href="../../library/#MatrixAlgebraKit.eig_vals"><code>eig_vals(!)</code></a> and <a href="../../library/#MatrixAlgebraKit.eig_trunc"><code>eig_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/interface/eig.jl#L23-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.eig_trunc-user_interface-decompositions" href="#MatrixAlgebraKit.eig_trunc-user_interface-decompositions"><code>MatrixAlgebraKit.eig_trunc</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eig_trunc(A; kwargs...) -&gt; D, V
eig_trunc(A, alg::AbstractAlgorithm) -&gt; D, V
eig_trunc!(A, [DV]; kwargs...) -&gt; D, V
eig_trunc!(A, [DV], alg::AbstractAlgorithm) -&gt; D, V</code></pre><p>Compute a partial or truncated eigenvalue decomposition of the matrix <code>A</code>, such that <code>A * V ≈ V * D</code>, where the (possibly rectangular) matrix <code>V</code> contains  a subset of eigenvectors and the diagonal matrix <code>D</code> contains the associated eigenvalues, selected according to a truncation strategy.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>eig_trunc!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note that <a href="../../library/#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and its variants do not assume additional structure on the input,</p></div></div><p>and therefore will always return complex eigenvalues and eigenvectors. For the real eigenvalue decomposition of symmetric or hermitian operators, see <a href="../../library/#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a>.</p><p>See also <a href="../../library/#MatrixAlgebraKit.eig_full"><code>eig_full(!)</code></a> and <a href="../../library/#MatrixAlgebraKit.eig_vals"><code>eig_vals(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/interface/eig.jl#L45-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.eig_vals-user_interface-decompositions" href="#MatrixAlgebraKit.eig_vals-user_interface-decompositions"><code>MatrixAlgebraKit.eig_vals</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eig_vals(A; kwargs...) -&gt; D
eig_vals(A, alg::AbstractAlgorithm) -&gt; D
eig_vals!(A, [D]; kwargs...) -&gt; D
eig_vals!(A, [D], alg::AbstractAlgorithm) -&gt; D</code></pre><p>Compute the list of eigenvalues of <code>A</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>eig_vals!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>D</code> as output.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note that <a href="../../library/#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and its variants do not assume additional structure on the input,</p></div></div><p>and therefore will always return complex eigenvalues and eigenvectors. For the real eigenvalue decomposition of symmetric or hermitian operators, see <a href="../../library/#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a>.</p><p>See also <a href="../../library/#MatrixAlgebraKit.eig_full"><code>eig_full(!)</code></a> and <a href="../../library/#MatrixAlgebraKit.eig_trunc"><code>eig_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/interface/eig.jl#L68-L85">source</a></section></article><p>Alongside these functions, we provide a LAPACK-based implementation for dense arrays, as provided by the following algorithms:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_Expert-user_interface-decompositions" href="#MatrixAlgebraKit.LAPACK_Expert-user_interface-decompositions"><code>MatrixAlgebraKit.LAPACK_Expert</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_Expert()</code></pre><p>Algorithm type to denote the expert LAPACK driver for computing the Schur or non-Hermitian eigenvalue decomposition of a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/implementations/decompositions.jl#L49-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_Simple-user_interface-decompositions" href="#MatrixAlgebraKit.LAPACK_Simple-user_interface-decompositions"><code>MatrixAlgebraKit.LAPACK_Simple</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_Simple()</code></pre><p>Algorithm type to denote the simple LAPACK driver for computing the Schur or non-Hermitian eigenvalue decomposition of a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/implementations/decompositions.jl#L41-L46">source</a></section></article><h2 id="Schur-Decomposition"><a class="docs-heading-anchor" href="#Schur-Decomposition">Schur Decomposition</a><a id="Schur-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Schur-Decomposition" title="Permalink"></a></h2><p>The <a href="https://en.wikipedia.org/wiki/Schur_decomposition">Schur decomposition</a> transforms a complex square matrix <code>A</code> into a product <code>Q * T * Qᴴ</code>, where <code>Q</code> is unitary and <code>T</code> is upper triangular. It rewrites an arbitrary complex square matrix as unitarily similar to an upper triangular matrix whose diagonal elements are the eigenvalues of <code>A</code>. For real matrices, the same decomposition can be achieved with <code>T</code> being quasi-upper triangular, ie triangular with blocks of size <code>(1, 1)</code> and <code>(2, 2)</code> on the diagonal.</p><p>This decomposition is also useful for computing the eigenvalues of a matrix, which is exposed through the <a href="../../library/#MatrixAlgebraKit.schur_vals"><code>schur_vals</code></a> function.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.schur_full-user_interface-decompositions" href="#MatrixAlgebraKit.schur_full-user_interface-decompositions"><code>MatrixAlgebraKit.schur_full</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">schur_full(A; kwargs...) -&gt; T, Z, vals
schur_full(A, alg::AbstractAlgorithm) -&gt; T, Z, vals
schur_full!(A, [TZv]; kwargs...) -&gt; T, Z, vals
schur_full!(A, [TZv], alg::AbstractAlgorithm) -&gt; T, Z, vals</code></pre><p>Compute the full Schur decomposition of the square matrix <code>A</code>, such that <code>A * Z = Z * T</code>, where the orthogonal or unitary matrix <code>Z</code> contains the Schur vectors and the square matrix <code>T</code> is upper triangular (in the complex case) or quasi-upper triangular (in the real case). The list <code>vals</code> contains the (complex-valued) eigenvalues of <code>A</code>, as extracted from the (quasi-)diagonal of <code>T</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>schur_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>TZv</code> as output.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/interface/schur.jl#L13-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.schur_vals-user_interface-decompositions" href="#MatrixAlgebraKit.schur_vals-user_interface-decompositions"><code>MatrixAlgebraKit.schur_vals</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">schur_vals(A; kwargs...) -&gt; vals
schur_vals(A, alg::AbstractAlgorithm) -&gt; vals
schur_vals!(A, [vals]; kwargs...) -&gt; vals
schur_vals!(A, [vals], alg::AbstractAlgorithm) -&gt; vals</code></pre><p>Compute the list of eigenvalues of <code>A</code> by computing the Schur decomposition of <code>A</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>schur_vals!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>vals</code> as output.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.eig_full"><code>eig_full(!)</code></a> and <a href="../../library/#MatrixAlgebraKit.eig_trunc"><code>eig_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/interface/schur.jl#L33-L47">source</a></section></article><p>The LAPACK-based implementation for dense arrays is provided by the following algorithms:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_Expert-user_interface-decompositions-2" href="#MatrixAlgebraKit.LAPACK_Expert-user_interface-decompositions-2"><code>MatrixAlgebraKit.LAPACK_Expert</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_Expert()</code></pre><p>Algorithm type to denote the expert LAPACK driver for computing the Schur or non-Hermitian eigenvalue decomposition of a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/implementations/decompositions.jl#L49-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_Simple-user_interface-decompositions-2" href="#MatrixAlgebraKit.LAPACK_Simple-user_interface-decompositions-2"><code>MatrixAlgebraKit.LAPACK_Simple</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_Simple()</code></pre><p>Algorithm type to denote the simple LAPACK driver for computing the Schur or non-Hermitian eigenvalue decomposition of a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/implementations/decompositions.jl#L41-L46">source</a></section></article><h2 id="Singular-Value-Decomposition"><a class="docs-heading-anchor" href="#Singular-Value-Decomposition">Singular Value Decomposition</a><a id="Singular-Value-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Singular-Value-Decomposition" title="Permalink"></a></h2><p>The <a href="https://en.wikipedia.org/wiki/Singular_value_decomposition">Singular Value Decomposition</a> transforms a matrix <code>A</code> into a product <code>U * Σ * Vᴴ</code>, where <code>U</code> and <code>V</code> are orthogonal, and <code>Σ</code> is diagonal, real and non-negative. For a square matrix <code>A</code>, both <code>U</code> and <code>V</code> are unitary, and if the singular values are distinct, the decomposition is unique.</p><p>For rectangular matrices <code>A</code> of size <code>(m, n)</code>, there are two modes of operation, <a href="../../library/#MatrixAlgebraKit.svd_full"><code>svd_full</code></a> and <a href="../../library/#MatrixAlgebraKit.svd_compact"><code>svd_compact</code></a>. The former ensures that the resulting <code>U</code>, and <code>V</code> remain square unitary matrices, of size <code>(m, m)</code> and <code>(n, n)</code>, with rectangular <code>Σ</code> of size <code>(m, n)</code>. The latter creates an isometric <code>U</code> of size <code>(m, min(m, n))</code>, and <code>V</code> of size <code>(n, min(m, n))</code>, with a square <code>Σ</code> of size <code>(min(m, n), min(m, n))</code>.</p><p>It is also possible to compute the singular values only, using the <a href="../../library/#MatrixAlgebraKit.svd_vals"><code>svd_vals</code></a> function. This then returns a vector of the values on the diagonal of <code>Σ</code>.</p><p>Finally, we also support computing a partial or truncated SVD, using the <a href="../../library/#MatrixAlgebraKit.svd_trunc"><code>svd_trunc</code></a> function.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.svd_full-user_interface-decompositions" href="#MatrixAlgebraKit.svd_full-user_interface-decompositions"><code>MatrixAlgebraKit.svd_full</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">svd_full(A; kwargs...) -&gt; U, S, Vᴴ
svd_full(A, alg::AbstractAlgorithm) -&gt; U, S, Vᴴ
svd_full!(A, [USVᴴ]; kwargs...) -&gt; U, S, Vᴴ
svd_full!(A, [USVᴴ], alg::AbstractAlgorithm) -&gt; U, S, Vᴴ</code></pre><p>Compute the full singular value decomposition (SVD) of the rectangular matrix <code>A</code> of size <code>(m, n)</code>, such that <code>A = U * S * Vᴴ</code>. Here, <code>U</code> and <code>Vᴴ</code> are unitary matrices of size <code>(m, m)</code> and <code>(n, n)</code> respectively, and <code>S</code> is a diagonal matrix of size <code>(m, n)</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>svd_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>USVᴴ</code> as output.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.svd_compact"><code>svd_compact(!)</code></a>, <a href="../../library/#MatrixAlgebraKit.svd_vals"><code>svd_vals(!)</code></a> and <a href="../../library/#MatrixAlgebraKit.svd_trunc"><code>svd_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/interface/svd.jl#L13-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.svd_compact-user_interface-decompositions" href="#MatrixAlgebraKit.svd_compact-user_interface-decompositions"><code>MatrixAlgebraKit.svd_compact</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">svd_compact(A; kwargs...) -&gt; U, S, Vᴴ
svd_compact(A, alg::AbstractAlgorithm) -&gt; U, S, Vᴴ
svd_compact!(A, [USVᴴ]; kwargs...) -&gt; U, S, Vᴴ
svd_compact!(A, [USVᴴ], alg::AbstractAlgorithm) -&gt; U, S, Vᴴ</code></pre><p>Compute the compact singular value decomposition (SVD) of the rectangular matrix <code>A</code> of size <code>(m, n)</code>, such that <code>A = U * S * Vᴴ</code>. Here, <code>U</code> is an isometric matrix (orthonormal columns) of size <code>(m, k)</code>, whereas  <code>Vᴴ</code> is a matrix of size <code>(k, n)</code> with orthonormal rows and <code>S</code> is a square diagonal matrix of size <code>(k, k)</code>, with <code>k = min(m, n)</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>svd_compact!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>USVᴴ</code> as output.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.svd_full"><code>svd_full(!)</code></a>, <a href="../../library/#MatrixAlgebraKit.svd_vals"><code>svd_vals(!)</code></a> and <a href="../../library/#MatrixAlgebraKit.svd_trunc"><code>svd_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/interface/svd.jl#L33-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.svd_vals-user_interface-decompositions" href="#MatrixAlgebraKit.svd_vals-user_interface-decompositions"><code>MatrixAlgebraKit.svd_vals</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">svd_vals(A; kwargs...) -&gt; S
svd_vals(A, alg::AbstractAlgorithm) -&gt; S
svd_vals!(A, [S]; kwargs...) -&gt; S
svd_vals!(A, [S], alg::AbstractAlgorithm) -&gt; S</code></pre><p>Compute the vector of singular values of <code>A</code>, such that for an M×N matrix <code>A</code>, <code>S</code> is a vector of size <code>K = min(M, N)</code>, the number of kept singular values.</p><p>See also <a href="../../library/#MatrixAlgebraKit.svd_full"><code>svd_full(!)</code></a>, <a href="../../library/#MatrixAlgebraKit.svd_compact"><code>svd_compact(!)</code></a> and <a href="../../library/#MatrixAlgebraKit.svd_trunc"><code>svd_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/interface/svd.jl#L77-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.svd_trunc-user_interface-decompositions" href="#MatrixAlgebraKit.svd_trunc-user_interface-decompositions"><code>MatrixAlgebraKit.svd_trunc</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">svd_trunc(A; kwargs...) -&gt; U, S, Vᴴ
svd_trunc(A, alg::AbstractAlgorithm) -&gt; U, S, Vᴴ
svd_trunc!(A, [USVᴴ]; kwargs...) -&gt; U, S, Vᴴ
svd_trunc!(A, [USVᴴ], alg::AbstractAlgorithm) -&gt; U, S, Vᴴ</code></pre><p>Compute a partial or truncated singular value decomposition (SVD) of <code>A</code>, such that <code>A * (Vᴴ)&#39; =  U * S</code>. Here, <code>U</code> is an isometric matrix (orthonormal columns) of size <code>(m, k)</code>, whereas  <code>Vᴴ</code> is a matrix of size <code>(k, n)</code> with orthonormal rows and <code>S</code> is a square diagonal matrix of size <code>(k, k)</code>, with <code>k</code> is set by the truncation strategy.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>svd_trunc!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>USVᴴ</code> as output.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.svd_full"><code>svd_full(!)</code></a>, <a href="../../library/#MatrixAlgebraKit.svd_compact"><code>svd_compact(!)</code></a> and <a href="../../library/#MatrixAlgebraKit.svd_vals"><code>svd_vals(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/interface/svd.jl#L55-L74">source</a></section></article><p>MatrixAlgebraKit again ships with LAPACK-based implementations for dense arrays:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_Bisection-user_interface-decompositions-2" href="#MatrixAlgebraKit.LAPACK_Bisection-user_interface-decompositions-2"><code>MatrixAlgebraKit.LAPACK_Bisection</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_Bisection()</code></pre><p>Algorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Bisection algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/implementations/decompositions.jl#L70-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_DivideAndConquer-user_interface-decompositions-2" href="#MatrixAlgebraKit.LAPACK_DivideAndConquer-user_interface-decompositions-2"><code>MatrixAlgebraKit.LAPACK_DivideAndConquer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_DivideAndConquer()</code></pre><p>Algorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Divide and Conquer algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/implementations/decompositions.jl#L79-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_Jacobi-user_interface-decompositions" href="#MatrixAlgebraKit.LAPACK_Jacobi-user_interface-decompositions"><code>MatrixAlgebraKit.LAPACK_Jacobi</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_Jacobi()</code></pre><p>Algorithm type to denote the LAPACK driver for computing the singular value decomposition of a general matrix using the Jacobi algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/implementations/decompositions.jl#L103-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_QRIteration-user_interface-decompositions-2" href="#MatrixAlgebraKit.LAPACK_QRIteration-user_interface-decompositions-2"><code>MatrixAlgebraKit.LAPACK_QRIteration</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_QRIteration()</code></pre><p>Algorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the QR Iteration algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/implementations/decompositions.jl#L61-L67">source</a></section></article><h2 id="Polar-Decomposition"><a class="docs-heading-anchor" href="#Polar-Decomposition">Polar Decomposition</a><a id="Polar-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Polar-Decomposition" title="Permalink"></a></h2><p>The <a href="https://en.wikipedia.org/wiki/Polar_decomposition">Polar Decomposition</a> of a matrix <code>A</code> is a factorization <code>A = W * P</code>, where <code>W</code> is unitary and <code>P</code> is positive semi-definite. If <code>A</code> is invertible (and therefore square), the polar decomposition always exists and is unique. For non-square matrices, the polar decomposition is not unique, but <code>P</code> is. In particular, the polar decomposition is unique if <code>A</code> is full rank.</p><p>This decomposition can be computed for both sides, resulting in the <a href="../../library/#MatrixAlgebraKit.left_polar"><code>left_polar</code></a> and <a href="../../library/#MatrixAlgebraKit.right_polar"><code>right_polar</code></a> functions.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.left_polar-user_interface-decompositions" href="#MatrixAlgebraKit.left_polar-user_interface-decompositions"><code>MatrixAlgebraKit.left_polar</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">left_polar(A; kwargs...) -&gt; W, P
left_polar(A, alg::AbstractAlgorithm) -&gt; W, P
left_polar!(A, [WP]; kwargs...) -&gt; W, P
left_polar!(A, [WP], alg::AbstractAlgorithm) -&gt; W, P</code></pre><p>Compute the full polar decomposition of the rectangular matrix <code>A</code> of size <code>(m, n)</code> with <code>m &gt;= n</code>, such that <code>A = W * P</code>. Here, <code>W</code> is an isometric matrix (orthonormal columns) of size <code>(m, n)</code>, whereas <code>P</code> is a positive (semi)definite matrix of size <code>(n, n)</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>left_polar!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>WP</code> as output.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.right_polar"><code>right_polar(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/interface/polar.jl#L12-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.right_polar-user_interface-decompositions" href="#MatrixAlgebraKit.right_polar-user_interface-decompositions"><code>MatrixAlgebraKit.right_polar</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">right_polar(A; kwargs...) -&gt; P, Wᴴ
right_polar(A, alg::AbstractAlgorithm) -&gt; P, Wᴴ
right_polar!(A, [PWᴴ]; kwargs...) -&gt; P, Wᴴ
right_polar!(A, [PWᴴ], alg::AbstractAlgorithm) -&gt; P, Wᴴ</code></pre><p>Compute the full polar decomposition of the rectangular matrix <code>A</code> of size <code>(m, n)</code> with <code>n &gt;= m</code>, such that <code>A = P * Wᴴ</code>. Here, <code>P</code> is a positive (semi)definite matrix of size <code>(m, m)</code>, whereas <code>Wᴴ</code> is a matrix with orthonormal rows (its adjoint is isometric) of size <code>(n, m)</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>right_polar!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>WP</code> as output.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.left_polar"><code>left_polar(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/interface/polar.jl#L31-L48">source</a></section></article><p>These functions are implemented by first computing a singular value decomposition, and then constructing the polar decomposition from the singular values and vectors. Therefore, the relevant LAPACK-based implementation is the one for the SVD:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.PolarViaSVD-user_interface-decompositions" href="#MatrixAlgebraKit.PolarViaSVD-user_interface-decompositions"><code>MatrixAlgebraKit.PolarViaSVD</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PolarViaSVD(svdalg)</code></pre><p>Algorithm for computing the polar decomposition of a matrix <code>A</code> via the singular value decomposition (SVD) of <code>A</code>. The <code>svdalg</code> argument specifies the SVD algorithm to use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/interface/polar.jl#L51-L56">source</a></section></article><h2 id="Orthogonal-Subspaces"><a class="docs-heading-anchor" href="#Orthogonal-Subspaces">Orthogonal Subspaces</a><a id="Orthogonal-Subspaces-1"></a><a class="docs-heading-anchor-permalink" href="#Orthogonal-Subspaces" title="Permalink"></a></h2><p>Often it is useful to compute orthogonal bases for a particular subspace defined by a matrix. Given a matrix <code>A</code> we can compute an orthonormal basis for its image or coimage, and factorize the matrix accordingly. These bases are accessible through <a href="../../library/#MatrixAlgebraKit.left_orth"><code>left_orth</code></a> and <a href="../../library/#MatrixAlgebraKit.right_orth"><code>right_orth</code></a> respectively. This is implemented through a combination of the decompositions mentioned above, and serves as a convenient interface to these operations.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.left_orth-user_interface-decompositions" href="#MatrixAlgebraKit.left_orth-user_interface-decompositions"><code>MatrixAlgebraKit.left_orth</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">left_orth(A; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -&gt; V, C
left_orth!(A, [VC]; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -&gt; V, C</code></pre><p>Compute an orthonormal basis <code>V</code> for the image of the matrix <code>A</code> of size <code>(m, n)</code>, as well as a  matrix <code>C</code> (the corestriction) such that <code>A</code> factors as <code>A = V * C</code>. The keyword argument <code>kind</code> can be used to specify the specific orthogonal decomposition that should be used to factor <code>A</code>, whereas <code>atol</code> and <code>rtol</code> can be used to control the precision in determining the rank of <code>A</code> via its singular values.</p><p>This is a high-level wrapper and will use one of the decompositions <code>qr!</code>, <code>svd!</code>, and <code>left_polar!</code> to compute the orthogonal basis <code>V</code>, as controlled by the keyword arguments.</p><p>When <code>kind</code> is provided, its possible values are</p><ul><li><p><code>kind == :qrpos</code>: <code>V</code> and <code>C</code> are computed using the positive QR decomposition.   This requires <code>iszero(atol) &amp;&amp; iszero(rtol)</code> and <code>left_orth!(A, [VC])</code> is equivalent to   <code>qr_compact!(A, [VC], alg)</code> with a default value <code>alg = select_algorithm(qr_compact!, A; positive=true)</code></p></li><li><p><code>kind == :qr</code>: <code>V</code> and <code>C</code> are computed using the QR decomposition,   This requires <code>iszero(atol) &amp;&amp; iszero(rtol)</code> and <code>left_orth!(A, [VC])</code> is equivalent to   <code>qr_compact!(A, [VC], alg)</code> with a default value <code>alg = select_algorithm(qr_compact!, A)</code></p></li><li><p><code>kind == :polar</code>: <code>V</code> and <code>C</code> are computed using the polar decomposition,   This requires <code>iszero(atol) &amp;&amp; iszero(rtol)</code> and <code>left_orth!(A, [VC])</code> is equivalent to   <code>left_polar!(A, [VC], alg)</code> with a default value <code>alg = select_algorithm(left_polar!, A)</code></p></li><li><p><code>kind == :svd</code>: <code>V</code> and <code>C</code> are computed using the singular value decomposition <code>svd_trunc!</code>,   where <code>V</code> will contain the left singular vectors corresponding to the singular values that   are larger than <code>max(atol, rtol * σ₁)</code>, where <code>σ₁</code> is the largest singular value of <code>A</code>.   <code>C</code> is computed as the product of the singular values and the right singular vectors,   i.e. with <code>U, S, Vᴴ = svd_trunc!(A)</code>, we have <code>V = U</code> and <code>C = S * Vᴴ</code>.</p></li></ul><p>When <code>kind</code> is not provided, the default value is <code>:qrpos</code> when <code>iszero(atol) &amp;&amp; iszero(rtol)</code> and <code>:svd</code> otherwise. Finally, finer control is obtained by providing an explicit algorithm using the <code>alg</code> keyword argument, which should be compatible with the chosen or default value of <code>kind</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>left_orth!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>CV</code> as output.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.right_orth"><code>right_orth(!)</code></a>, <a href="../../library/#MatrixAlgebraKit.left_orth"><code>left_orth(!)</code></a>, <a href="../../library/#MatrixAlgebraKit.right_orth"><code>right_orth(!)</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/interface/orthnull.jl#L21-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.right_orth-user_interface-decompositions" href="#MatrixAlgebraKit.right_orth-user_interface-decompositions"><code>MatrixAlgebraKit.right_orth</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">right_orth(A; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -&gt; C, Vᴴ
right_orth!(A, [CVᴴ]; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -&gt; C, Vᴴ</code></pre><p>Compute an orthonormal basis <code>V = adjoint(Vᴴ)</code> for the coimage of the matrix <code>A</code>, i.e. for the image of <code>adjoint(A)</code>, as well as a matrix <code>C</code> such that <code>A = C * Vᴴ</code>. The keyword argument <code>kind</code> can be used to specify the specific orthogonal decomposition that should be used to factor <code>A</code>, whereas <code>atol</code> and <code>rtol</code> can be used to control the precision in determining the rank of <code>A</code> via its singular values.</p><p>This is a high-level wrapper and will use call one of the decompositions <code>qr!</code>, <code>svd!</code>, and <code>left_polar!</code> to compute the orthogonal basis <code>V</code>, as controlled by the keyword arguments.</p><p>When <code>kind</code> is provided, its possible values are</p><ul><li><p><code>kind == :lqpos</code>: <code>C</code> and <code>Vᴴ</code> are computed using the positive QR decomposition.   This requires <code>iszero(atol) &amp;&amp; iszero(rtol)</code> and <code>right_orth!(A, [CVᴴ])</code> is equivalent to   <code>lq_compact!(A, [CVᴴ], alg)</code> with a default value <code>alg = select_algorithm(lq_compact!, A; positive=true)</code></p></li><li><p><code>kind == :lq</code>: <code>C</code> and <code>Vᴴ</code> are computed using the QR decomposition,   This requires <code>iszero(atol) &amp;&amp; iszero(rtol)</code> and <code>right_orth!(A, [CVᴴ])</code> is equivalent to   <code>lq_compact!(A, [CVᴴ], alg)</code> with a default value <code>alg = select_algorithm(lq_compact!, A))</code></p></li><li><p><code>kind == :polar</code>: <code>C</code> and <code>Vᴴ</code> are computed using the polar decomposition,   This requires <code>iszero(atol) &amp;&amp; iszero(rtol)</code> and <code>right_orth!(A, [CVᴴ])</code> is equivalent to   <code>right_polar!(A, [CVᴴ], alg)</code> with a default value <code>alg = select_algorithm(right_polar!, A))</code></p></li><li><p><code>kind == :svd</code>: <code>C</code> and <code>Vᴴ</code> are computed using the singular value decomposition <code>svd_trunc!</code>,   where <code>V = adjoint(Vᴴ)</code> will contain the right singular vectors corresponding to the singular   values that are larger than <code>max(atol, rtol * σ₁)</code>, where <code>σ₁</code> is the largest singular value of <code>A</code>.   <code>C</code> is computed as the product of the singular values and the right singular vectors,   i.e. with <code>U, S, Vᴴ = svd_trunc!(A)</code>, we have <code>C = rmul!(U, S)</code> and <code>Vᴴ = Vᴴ</code>.</p></li></ul><p>When <code>kind</code> is not provided, the default value is <code>:lqpos</code> when <code>iszero(atol) &amp;&amp; iszero(rtol)</code> and <code>:svd</code> otherwise. Finally, finer control is obtained by providing an explicit algorithm using the <code>alg</code> keyword argument, which should be compatible with the chosen or default value of <code>kind</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>right_orth!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>CVᴴ</code> as output.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.left_orth"><code>left_orth(!)</code></a>, <a href="../../library/#MatrixAlgebraKit.left_orth"><code>left_orth(!)</code></a>, <a href="../../library/#MatrixAlgebraKit.right_orth"><code>right_orth(!)</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/interface/orthnull.jl#L76-L121">source</a></section></article><h2 id="Null-Spaces"><a class="docs-heading-anchor" href="#Null-Spaces">Null Spaces</a><a id="Null-Spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Null-Spaces" title="Permalink"></a></h2><p>Similarly, it can be convenient to obtain an orthogonal basis for the kernel or cokernel of a matrix. These are the compliments of the image and coimage, and can be computed using the <a href="../../library/#MatrixAlgebraKit.left_null"><code>left_null</code></a> and <a href="../../library/#MatrixAlgebraKit.right_null"><code>right_null</code></a> functions. Again, this is typically implemented through a combination of the decompositions mentioned above, and serves as a convenient interface to these operations.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.left_null-user_interface-decompositions" href="#MatrixAlgebraKit.left_null-user_interface-decompositions"><code>MatrixAlgebraKit.left_null</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">left_null(A; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -&gt; N
left_null!(A, [N]; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -&gt; N</code></pre><p>Compute an orthonormal basis <code>N</code> for the cokernel of the matrix <code>A</code> of size <code>(m, n)</code>, i.e. the nullspace of <code>adjoint(A)</code>, such that <code>adjoint(A)*N ≈ 0</code> and <code>N&#39;*N ≈ I</code>. The keyword argument <code>kind</code> can be used to specify the specific orthogonal decomposition that should be used to factor <code>A</code>, whereas <code>atol</code> and <code>rtol</code> can be used to control the precision in determining the rank of <code>A</code> via its singular values.</p><p>This is a high-level wrapper and will use one of the decompositions <code>qr!</code> or <code>svd!</code> to compute the orthogonal basis <code>N</code>, as controlled by the keyword arguments.</p><p>When <code>kind</code> is provided, its possible values are</p><ul><li><p><code>kind == :qrpos</code>: <code>N</code> is computed using the positive QR decomposition.   This requires <code>iszero(atol) &amp;&amp; iszero(rtol)</code> and <code>left_null!(A, [N], kind=:qrpos)</code> is equivalent to   <code>qr_null!(A, [N], alg)</code> with a default value <code>alg = select_algorithm(qr_compact!, A; positive=true)</code></p></li><li><p><code>kind == :qr</code>: <code>N</code> is computed using the (nonpositive) QR decomposition.   This requires <code>iszero(atol) &amp;&amp; iszero(rtol)</code> and <code>left_null!(A, [N], kind=:qr)</code> is equivalent to   <code>qr_null!(A, [N], alg)</code> with a default value <code>alg = select_algorithm(qr_compact!, A)</code></p></li><li><p><code>kind == :svd</code>: <code>N</code> is computed using the singular value decomposition and will contain    the left singular vectors corresponding to the singular values that   are smaller than <code>max(atol, rtol * σ₁)</code>, where <code>σ₁</code> is the largest singular value of <code>A</code>.</p></li></ul><p>When <code>kind</code> is not provided, the default value is <code>:qrpos</code> when <code>iszero(atol) &amp;&amp; iszero(rtol)</code> and <code>:svd</code> otherwise. Finally, finer control is obtained by providing an explicit algorithm using the <code>alg</code> keyword argument, which should be compatible with the chosen or default value of <code>kind</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>left_null!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>N</code> as output.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.right_null"><code>right_null(!)</code></a>, <a href="../../library/#MatrixAlgebraKit.left_orth"><code>left_orth(!)</code></a>, <a href="../../library/#MatrixAlgebraKit.right_orth"><code>right_orth(!)</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/interface/orthnull.jl#L133-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.right_null-user_interface-decompositions" href="#MatrixAlgebraKit.right_null-user_interface-decompositions"><code>MatrixAlgebraKit.right_null</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">right_null(A; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -&gt; Nᴴ
right_null!(A, [Nᴴ]; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -&gt; Nᴴ</code></pre><p>Compute an orthonormal basis <code>N = adjoint(Nᴴ)</code> for the kernel or nullspace of the matrix <code>A</code> of size <code>(m, n)</code>, such that <code>A*adjoint(Nᴴ) ≈ 0</code> and <code>Nᴴ*adjoint(Nᴴ) ≈ I</code>. The keyword argument <code>kind</code> can be used to specify the specific orthogonal decomposition that should be used to factor <code>A</code>, whereas <code>atol</code> and <code>rtol</code> can be used to control the precision in determining the rank of <code>A</code> via its singular values.</p><p>This is a high-level wrapper and will use one of the decompositions <code>lq!</code> or <code>svd!</code> to compute the orthogonal basis <code>Nᴴ</code>, as controlled by the keyword arguments.</p><p>When <code>kind</code> is provided, its possible values are</p><ul><li><p><code>kind == :lqpos</code>: <code>Nᴴ</code> is computed using the positive LQ decomposition.   This requires <code>iszero(atol) &amp;&amp; iszero(rtol)</code> and <code>right_null!(A, [Nᴴ], kind=:lqpos)</code> is equivalent to   <code>lq_null!(A, [Nᴴ], alg)</code> with a default value <code>alg = select_algorithm(lq_compact!, A; positive=true)</code></p></li><li><p><code>kind == :lq</code>: <code>Nᴴ</code> is computed using the (nonpositive) LQ decomposition.   This requires <code>iszero(atol) &amp;&amp; iszero(rtol)</code> and <code>right_null!(A, [Nᴴ], kind=:lq)</code> is equivalent to   <code>lq_null!(A, [Nᴴ], alg)</code> with a default value <code>alg = select_algorithm(lq_compact!, A)</code></p></li><li><p><code>kind == :svd</code>: <code>N</code> is computed using the singular value decomposition and will contain    the left singular vectors corresponding to the singular values that   are smaller than <code>max(atol, rtol * σ₁)</code>, where <code>σ₁</code> is the largest singular value of <code>A</code>.</p></li></ul><p>When <code>kind</code> is not provided, the default value is <code>:lqpos</code> when <code>iszero(atol) &amp;&amp; iszero(rtol)</code> and <code>:svd</code> otherwise. Finally, finer control is obtained by providing an explicit algorithm using the <code>alg</code> keyword argument, which should be compatible with the chosen or default value of <code>kind</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>right_null!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>Nᴴ</code> as output.</p></div></div><p>See also <a href="../../library/#MatrixAlgebraKit.left_null"><code>left_null(!)</code></a>, <a href="../../library/#MatrixAlgebraKit.left_orth"><code>left_orth(!)</code></a>, <a href="../../library/#MatrixAlgebraKit.right_orth"><code>right_orth(!)</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/13e624577b183133a17947342cc1e84f5e23eadd/src/interface/orthnull.jl#L181-L219">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../compositions/">« Compositions</a><a class="docs-footer-nextpage" href="../truncations/">Truncations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Sunday 16 March 2025 00:58">Sunday 16 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
