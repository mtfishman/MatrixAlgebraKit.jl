<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · MatrixAlgebraKit.jl</title><meta name="title" content="Library · MatrixAlgebraKit.jl"/><meta property="og:title" content="Library · MatrixAlgebraKit.jl"/><meta property="twitter:title" content="Library · MatrixAlgebraKit.jl"/><meta name="description" content="Documentation for MatrixAlgebraKit.jl."/><meta property="og:description" content="Documentation for MatrixAlgebraKit.jl."/><meta property="twitter:description" content="Documentation for MatrixAlgebraKit.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MatrixAlgebraKit.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">User Interface</span><ul><li><a class="tocitem" href="../user_interface/compositions/">Compositions</a></li><li><a class="tocitem" href="../user_interface/decompositions/">Decompositions</a></li><li><a class="tocitem" href="../user_interface/truncations/">Truncations</a></li><li><a class="tocitem" href="../user_interface/matrix_functions/">Matrix functions</a></li></ul></li><li><a class="tocitem" href="../dev_interface/">Developer Interface</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Constants-and-types"><span>Constants and types</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Other"><span>Other</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/main/docs/src/library.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library-documentation"><a class="docs-heading-anchor" href="#Library-documentation">Library documentation</a><a id="Library-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Library-documentation" title="Permalink"></a></h1><h2 id="Constants-and-types"><a class="docs-heading-anchor" href="#Constants-and-types">Constants and types</a><a id="Constants-and-types-1"></a><a class="docs-heading-anchor-permalink" href="#Constants-and-types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.AbstractAlgorithm" href="#MatrixAlgebraKit.AbstractAlgorithm"><code>MatrixAlgebraKit.AbstractAlgorithm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractAlgorithm end</code></pre><p>Supertype to dispatch on specific implementations of different the different functions. Concrete subtypes should represent both a way to dispatch to a given implementation, as well as the configuration of that implementation.</p><p>See also <a href="#MatrixAlgebraKit.select_algorithm"><code>select_algorithm</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/algorithms.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.Algorithm" href="#MatrixAlgebraKit.Algorithm"><code>MatrixAlgebraKit.Algorithm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Algorithm{name,KW} &lt;: AbstractAlgorithm</code></pre><p>Bare-bones implementation of an algorithm, where <code>name</code> should be a <code>Symbol</code> to dispatch on, and <code>KW</code> is typically a <code>NamedTuple</code> indicating the keyword arguments.</p><p>See also <a href="#MatrixAlgebraKit.@algdef-Tuple{Any}"><code>@algdef</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/algorithms.jl#L12-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_Bisection" href="#MatrixAlgebraKit.LAPACK_Bisection"><code>MatrixAlgebraKit.LAPACK_Bisection</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_Bisection()</code></pre><p>Algorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Bisection algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/implementations/decompositions.jl#L70-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_DivideAndConquer" href="#MatrixAlgebraKit.LAPACK_DivideAndConquer"><code>MatrixAlgebraKit.LAPACK_DivideAndConquer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_DivideAndConquer()</code></pre><p>Algorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the Divide and Conquer algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/implementations/decompositions.jl#L79-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_Expert" href="#MatrixAlgebraKit.LAPACK_Expert"><code>MatrixAlgebraKit.LAPACK_Expert</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_Expert()</code></pre><p>Algorithm type to denote the expert LAPACK driver for computing the Schur or non-Hermitian eigenvalue decomposition of a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/implementations/decompositions.jl#L49-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_HouseholderLQ" href="#MatrixAlgebraKit.LAPACK_HouseholderLQ"><code>MatrixAlgebraKit.LAPACK_HouseholderLQ</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_HoudeholderLQ(; blocksize, positive = false)</code></pre><p>Algorithm type to denote the standard LAPACK algorithm for computing the LQ decomposition of a matrix using Householder reflectors. The specific LAPACK function can be controlled using the keyword arugments, i.e. <code>?gelqt</code> will be chosen if <code>blocksize &gt; 1</code> or <code>?gelqf</code> will be chosen if <code>blocksize == 1</code>. The keyword <code>positive =true</code> can be used to ensure that the diagonal elements of <code>L</code> are non-negative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/implementations/decompositions.jl#L24-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_HouseholderQR" href="#MatrixAlgebraKit.LAPACK_HouseholderQR"><code>MatrixAlgebraKit.LAPACK_HouseholderQR</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_HoudeholderQR(; blocksize, positive = false, pivoted = false)</code></pre><p>Algorithm type to denote the standard LAPACK algorithm for computing the QR decomposition of a matrix using Householder reflectors. The specific LAPACK function can be controlled using the keyword arugments, i.e.  <code>?geqrt</code> will be chosen if <code>blocksize &gt; 1</code>. With <code>blocksize == 1</code>, <code>?geqrf</code> will be chosen if <code>pivoted == false</code> and <code>?geqp3</code> will be chosen if <code>pivoted == true</code>. The keyword <code>positive =true</code> can be used to ensure that the diagonal elements of <code>R</code> are non-negative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/implementations/decompositions.jl#L12-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_Jacobi" href="#MatrixAlgebraKit.LAPACK_Jacobi"><code>MatrixAlgebraKit.LAPACK_Jacobi</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_Jacobi()</code></pre><p>Algorithm type to denote the LAPACK driver for computing the singular value decomposition of a general matrix using the Jacobi algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/implementations/decompositions.jl#L103-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_MultipleRelativelyRobustRepresentations" href="#MatrixAlgebraKit.LAPACK_MultipleRelativelyRobustRepresentations"><code>MatrixAlgebraKit.LAPACK_MultipleRelativelyRobustRepresentations</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_MultipleRelativelyRobustRepresentations()</code></pre><p>Algorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix using the Multiple Relatively Robust Representations algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/implementations/decompositions.jl#L88-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_QRIteration" href="#MatrixAlgebraKit.LAPACK_QRIteration"><code>MatrixAlgebraKit.LAPACK_QRIteration</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_QRIteration()</code></pre><p>Algorithm type to denote the LAPACK driver for computing the eigenvalue decomposition of a Hermitian matrix, or the singular value decomposition of a general matrix using the QR Iteration algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/implementations/decompositions.jl#L61-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.LAPACK_Simple" href="#MatrixAlgebraKit.LAPACK_Simple"><code>MatrixAlgebraKit.LAPACK_Simple</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LAPACK_Simple()</code></pre><p>Algorithm type to denote the simple LAPACK driver for computing the Schur or non-Hermitian eigenvalue decomposition of a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/implementations/decompositions.jl#L41-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.NoTruncation" href="#MatrixAlgebraKit.NoTruncation"><code>MatrixAlgebraKit.NoTruncation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoTruncation()</code></pre><p>Trivial truncation strategy that keeps all values, mostly for testing purposes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/implementations/truncation.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.PolarViaSVD" href="#MatrixAlgebraKit.PolarViaSVD"><code>MatrixAlgebraKit.PolarViaSVD</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PolarViaSVD(svdalg)</code></pre><p>Algorithm for computing the polar decomposition of a matrix <code>A</code> via the singular value decomposition (SVD) of <code>A</code>. The <code>svdalg</code> argument specifies the SVD algorithm to use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/polar.jl#L51-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.TruncatedAlgorithm" href="#MatrixAlgebraKit.TruncatedAlgorithm"><code>MatrixAlgebraKit.TruncatedAlgorithm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TruncatedAlgorithm(alg::AbstractAlgorithm, trunc::TruncationAlgorithm)</code></pre><p>Generic wrapper type for algorithms that consist of first using <code>alg</code>, followed by a truncation through <code>trunc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/implementations/truncation.jl#L150-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.TruncationKeepFiltered" href="#MatrixAlgebraKit.TruncationKeepFiltered"><code>MatrixAlgebraKit.TruncationKeepFiltered</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TruncationKeepFiltered(filter::Function)</code></pre><p>Truncation strategy to keep the values for which <code>filter</code> returns true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/implementations/truncation.jl#L42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.TruncationKeepSorted" href="#MatrixAlgebraKit.TruncationKeepSorted"><code>MatrixAlgebraKit.TruncationKeepSorted</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TruncationKeepSorted(howmany::Int, sortby::Function, rev::Bool)</code></pre><p>Truncation strategy to keep the first <code>howmany</code> values when sorted according to <code>sortby</code> or the last <code>howmany</code> if <code>rev</code> is true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/implementations/truncation.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.TruncationStrategy" href="#MatrixAlgebraKit.TruncationStrategy"><code>MatrixAlgebraKit.TruncationStrategy</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type TruncationStrategy end</code></pre><p>Supertype to denote different strategies for truncated decompositions that are implemented via post-truncation.</p><p>See also <a href="#MatrixAlgebraKit.truncate!"><code>truncate!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/implementations/truncation.jl#L1-L7">source</a></section></article><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.copy_input" href="#MatrixAlgebraKit.copy_input"><code>MatrixAlgebraKit.copy_input</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">copy_input(f, A)</code></pre><p>Preprocess the input <code>A</code> for a given function, such that it may be handled correctly later. This may include a copy whenever the implementation would destroy the original matrix, or a change of element type to something that is supported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/algorithms.jl#L64-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.default_pullback_gaugetol-Tuple{Any}" href="#MatrixAlgebraKit.default_pullback_gaugetol-Tuple{Any}"><code>MatrixAlgebraKit.default_pullback_gaugetol</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">default_pullback_gaugetol(a)</code></pre><p>Default tolerance for deciding to warn if incoming adjoints of a pullback rule has components that are not gauge-invariant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/common/defaults.jl#L12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.defaulttol-Tuple{Any}" href="#MatrixAlgebraKit.defaulttol-Tuple{Any}"><code>MatrixAlgebraKit.defaulttol</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">defaulttol(x)</code></pre><p>Default tolerance or precision for a given object, e.g. to decide when it can be considerd to be zero or ignored in some other way, or how accurate some quantity needs to be computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/common/defaults.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.eig_full" href="#MatrixAlgebraKit.eig_full"><code>MatrixAlgebraKit.eig_full</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eig_full(A; kwargs...) -&gt; D, V
eig_full(A, alg::AbstractAlgorithm) -&gt; D, V
eig_full!(A, [DV]; kwargs...) -&gt; D, V
eig_full!(A, [DV], alg::AbstractAlgorithm) -&gt; D, V</code></pre><p>Compute the full eigenvalue decomposition of the square matrix <code>A</code>, such that <code>A * V = V * D</code>, where the invertible matrix <code>V</code> contains the eigenvectors and the diagonal matrix <code>D</code> contains the associated eigenvalues.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>eig_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and its variants do not assume additional structure on the input,</p></div></div><p>and therefore will always return complex eigenvalues and eigenvectors. For the real eigenvalue decomposition of symmetric or hermitian operators, see <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a>.</p><p>See also <a href="#MatrixAlgebraKit.eig_vals"><code>eig_vals(!)</code></a> and <a href="#MatrixAlgebraKit.eig_trunc"><code>eig_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/eig.jl#L23-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.eig_full!" href="#MatrixAlgebraKit.eig_full!"><code>MatrixAlgebraKit.eig_full!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eig_full(A; kwargs...) -&gt; D, V
eig_full(A, alg::AbstractAlgorithm) -&gt; D, V
eig_full!(A, [DV]; kwargs...) -&gt; D, V
eig_full!(A, [DV], alg::AbstractAlgorithm) -&gt; D, V</code></pre><p>Compute the full eigenvalue decomposition of the square matrix <code>A</code>, such that <code>A * V = V * D</code>, where the invertible matrix <code>V</code> contains the eigenvectors and the diagonal matrix <code>D</code> contains the associated eigenvalues.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>eig_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and its variants do not assume additional structure on the input,</p></div></div><p>and therefore will always return complex eigenvalues and eigenvectors. For the real eigenvalue decomposition of symmetric or hermitian operators, see <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a>.</p><p>See also <a href="#MatrixAlgebraKit.eig_vals"><code>eig_vals(!)</code></a> and <a href="#MatrixAlgebraKit.eig_trunc"><code>eig_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/eig.jl#L23-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.eig_trunc" href="#MatrixAlgebraKit.eig_trunc"><code>MatrixAlgebraKit.eig_trunc</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eig_trunc(A; kwargs...) -&gt; D, V
eig_trunc(A, alg::AbstractAlgorithm) -&gt; D, V
eig_trunc!(A, [DV]; kwargs...) -&gt; D, V
eig_trunc!(A, [DV], alg::AbstractAlgorithm) -&gt; D, V</code></pre><p>Compute a partial or truncated eigenvalue decomposition of the matrix <code>A</code>, such that <code>A * V ≈ V * D</code>, where the (possibly rectangular) matrix <code>V</code> contains  a subset of eigenvectors and the diagonal matrix <code>D</code> contains the associated eigenvalues, selected according to a truncation strategy.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>eig_trunc!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and its variants do not assume additional structure on the input,</p></div></div><p>and therefore will always return complex eigenvalues and eigenvectors. For the real eigenvalue decomposition of symmetric or hermitian operators, see <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a>.</p><p>See also <a href="#MatrixAlgebraKit.eig_full"><code>eig_full(!)</code></a> and <a href="#MatrixAlgebraKit.eig_vals"><code>eig_vals(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/eig.jl#L45-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.eig_trunc!" href="#MatrixAlgebraKit.eig_trunc!"><code>MatrixAlgebraKit.eig_trunc!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eig_trunc(A; kwargs...) -&gt; D, V
eig_trunc(A, alg::AbstractAlgorithm) -&gt; D, V
eig_trunc!(A, [DV]; kwargs...) -&gt; D, V
eig_trunc!(A, [DV], alg::AbstractAlgorithm) -&gt; D, V</code></pre><p>Compute a partial or truncated eigenvalue decomposition of the matrix <code>A</code>, such that <code>A * V ≈ V * D</code>, where the (possibly rectangular) matrix <code>V</code> contains  a subset of eigenvectors and the diagonal matrix <code>D</code> contains the associated eigenvalues, selected according to a truncation strategy.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>eig_trunc!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and its variants do not assume additional structure on the input,</p></div></div><p>and therefore will always return complex eigenvalues and eigenvectors. For the real eigenvalue decomposition of symmetric or hermitian operators, see <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a>.</p><p>See also <a href="#MatrixAlgebraKit.eig_full"><code>eig_full(!)</code></a> and <a href="#MatrixAlgebraKit.eig_vals"><code>eig_vals(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/eig.jl#L45-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.eig_vals" href="#MatrixAlgebraKit.eig_vals"><code>MatrixAlgebraKit.eig_vals</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eig_vals(A; kwargs...) -&gt; D
eig_vals(A, alg::AbstractAlgorithm) -&gt; D
eig_vals!(A, [D]; kwargs...) -&gt; D
eig_vals!(A, [D], alg::AbstractAlgorithm) -&gt; D</code></pre><p>Compute the list of eigenvalues of <code>A</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>eig_vals!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>D</code> as output.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and its variants do not assume additional structure on the input,</p></div></div><p>and therefore will always return complex eigenvalues and eigenvectors. For the real eigenvalue decomposition of symmetric or hermitian operators, see <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a>.</p><p>See also <a href="#MatrixAlgebraKit.eig_full"><code>eig_full(!)</code></a> and <a href="#MatrixAlgebraKit.eig_trunc"><code>eig_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/eig.jl#L68-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.eig_vals!" href="#MatrixAlgebraKit.eig_vals!"><code>MatrixAlgebraKit.eig_vals!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eig_vals(A; kwargs...) -&gt; D
eig_vals(A, alg::AbstractAlgorithm) -&gt; D
eig_vals!(A, [D]; kwargs...) -&gt; D
eig_vals!(A, [D], alg::AbstractAlgorithm) -&gt; D</code></pre><p>Compute the list of eigenvalues of <code>A</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>eig_vals!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>D</code> as output.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.eig_full"><code>eig_full</code></a> and its variants do not assume additional structure on the input,</p></div></div><p>and therefore will always return complex eigenvalues and eigenvectors. For the real eigenvalue decomposition of symmetric or hermitian operators, see <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a>.</p><p>See also <a href="#MatrixAlgebraKit.eig_full"><code>eig_full(!)</code></a> and <a href="#MatrixAlgebraKit.eig_trunc"><code>eig_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/eig.jl#L68-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.eigh_full" href="#MatrixAlgebraKit.eigh_full"><code>MatrixAlgebraKit.eigh_full</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eigh_full(A; kwargs...) -&gt; D, V
eigh_full(A, alg::AbstractAlgorithm) -&gt; D, V
eigh_full!(A, [DV]; kwargs...) -&gt; D, V
eigh_full!(A, [DV], alg::AbstractAlgorithm) -&gt; D, V</code></pre><p>Compute the full eigenvalue decomposition of the symmetric or hermitian matrix <code>A</code>, such that <code>A * V = V * D</code>, where the unitary matrix <code>V</code> contains the orthogonal eigenvectors and the real diagonal matrix <code>D</code> contains the associated eigenvalues.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>eigh_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a> and its variants assume additional structure on the input,</p></div></div><p>and therefore will retain the <code>eltype</code> of the input for the eigenvalues and eigenvectors. For generic eigenvalue decompositions, see <a href="#MatrixAlgebraKit.eig_full"><code>eig_full</code></a>.</p><p>See also <a href="#MatrixAlgebraKit.eigh_vals"><code>eigh_vals(!)</code></a> and <a href="#MatrixAlgebraKit.eigh_trunc"><code>eigh_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/eigh.jl#L22-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.eigh_full!" href="#MatrixAlgebraKit.eigh_full!"><code>MatrixAlgebraKit.eigh_full!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eigh_full(A; kwargs...) -&gt; D, V
eigh_full(A, alg::AbstractAlgorithm) -&gt; D, V
eigh_full!(A, [DV]; kwargs...) -&gt; D, V
eigh_full!(A, [DV], alg::AbstractAlgorithm) -&gt; D, V</code></pre><p>Compute the full eigenvalue decomposition of the symmetric or hermitian matrix <code>A</code>, such that <code>A * V = V * D</code>, where the unitary matrix <code>V</code> contains the orthogonal eigenvectors and the real diagonal matrix <code>D</code> contains the associated eigenvalues.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>eigh_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a> and its variants assume additional structure on the input,</p></div></div><p>and therefore will retain the <code>eltype</code> of the input for the eigenvalues and eigenvectors. For generic eigenvalue decompositions, see <a href="#MatrixAlgebraKit.eig_full"><code>eig_full</code></a>.</p><p>See also <a href="#MatrixAlgebraKit.eigh_vals"><code>eigh_vals(!)</code></a> and <a href="#MatrixAlgebraKit.eigh_trunc"><code>eigh_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/eigh.jl#L22-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.eigh_trunc" href="#MatrixAlgebraKit.eigh_trunc"><code>MatrixAlgebraKit.eigh_trunc</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eigh_trunc(A; kwargs...) -&gt; D, V
eigh_trunc(A, alg::AbstractAlgorithm) -&gt; D, V
eigh_trunc!(A, [DV]; kwargs...) -&gt; D, V
eigh_trunc!(A, [DV], alg::AbstractAlgorithm) -&gt; D, V</code></pre><p>Compute a partial or truncated eigenvalue decomposition of the symmetric or hermitian matrix <code>A</code>, such that <code>A * V ≈ V * D</code>, where the isometric matrix <code>V</code> contains a subset of the orthogonal eigenvectors and the real diagonal matrix <code>D</code> contains the associated eigenvalues, selected according to a truncation strategy. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>eigh_trunc!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a> and its variants assume additional structure on the input,</p></div></div><p>and therefore will retain the <code>eltype</code> of the input for the eigenvalues and eigenvectors. For generic eigenvalue decompositions, see <a href="#MatrixAlgebraKit.eig_full"><code>eig_full</code></a>.</p><p>See also <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full(!)</code></a> and <a href="#MatrixAlgebraKit.eigh_vals"><code>eigh_vals(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/eigh.jl#L44-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.eigh_trunc!" href="#MatrixAlgebraKit.eigh_trunc!"><code>MatrixAlgebraKit.eigh_trunc!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eigh_trunc(A; kwargs...) -&gt; D, V
eigh_trunc(A, alg::AbstractAlgorithm) -&gt; D, V
eigh_trunc!(A, [DV]; kwargs...) -&gt; D, V
eigh_trunc!(A, [DV], alg::AbstractAlgorithm) -&gt; D, V</code></pre><p>Compute a partial or truncated eigenvalue decomposition of the symmetric or hermitian matrix <code>A</code>, such that <code>A * V ≈ V * D</code>, where the isometric matrix <code>V</code> contains a subset of the orthogonal eigenvectors and the real diagonal matrix <code>D</code> contains the associated eigenvalues, selected according to a truncation strategy. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>eigh_trunc!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a> and its variants assume additional structure on the input,</p></div></div><p>and therefore will retain the <code>eltype</code> of the input for the eigenvalues and eigenvectors. For generic eigenvalue decompositions, see <a href="#MatrixAlgebraKit.eig_full"><code>eig_full</code></a>.</p><p>See also <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full(!)</code></a> and <a href="#MatrixAlgebraKit.eigh_vals"><code>eigh_vals(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/eigh.jl#L44-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.eigh_vals" href="#MatrixAlgebraKit.eigh_vals"><code>MatrixAlgebraKit.eigh_vals</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eigh_vals(A; kwargs...) -&gt; D
eigh_vals(A, alg::AbstractAlgorithm) -&gt; D
eigh_vals!(A, [D]; kwargs...) -&gt; D
eigh_vals!(A, [D], alg::AbstractAlgorithm) -&gt; D</code></pre><p>Compute the list of (real) eigenvalues of the symmetric or hermitian matrix <code>A</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>eigh_vals!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a> and its variants assume additional structure on the input,</p></div></div><p>and therefore will retain the <code>eltype</code> of the input for the eigenvalues and eigenvectors. For generic eigenvalue decompositions, see <a href="#MatrixAlgebraKit.eig_full"><code>eig_full</code></a>.</p><p>See also <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full(!)</code></a> and <a href="#MatrixAlgebraKit.eigh_trunc"><code>eigh_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/eigh.jl#L67-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.eigh_vals!" href="#MatrixAlgebraKit.eigh_vals!"><code>MatrixAlgebraKit.eigh_vals!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eigh_vals(A; kwargs...) -&gt; D
eigh_vals(A, alg::AbstractAlgorithm) -&gt; D
eigh_vals!(A, [D]; kwargs...) -&gt; D
eigh_vals!(A, [D], alg::AbstractAlgorithm) -&gt; D</code></pre><p>Compute the list of (real) eigenvalues of the symmetric or hermitian matrix <code>A</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>eigh_vals!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>DV</code> as output.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note that <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full</code></a> and its variants assume additional structure on the input,</p></div></div><p>and therefore will retain the <code>eltype</code> of the input for the eigenvalues and eigenvectors. For generic eigenvalue decompositions, see <a href="#MatrixAlgebraKit.eig_full"><code>eig_full</code></a>.</p><p>See also <a href="#MatrixAlgebraKit.eigh_full"><code>eigh_full(!)</code></a> and <a href="#MatrixAlgebraKit.eigh_trunc"><code>eigh_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/eigh.jl#L67-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.initialize_output" href="#MatrixAlgebraKit.initialize_output"><code>MatrixAlgebraKit.initialize_output</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize_output(f, A, alg)</code></pre><p>Whenever possible, allocate the destination for applying a given algorithm in-place. If this is not possible, for example when the output size is not known a priori or immutable, this function may return <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/algorithms.jl#L73-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.inv_regularized" href="#MatrixAlgebraKit.inv_regularized"><code>MatrixAlgebraKit.inv_regularized</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inv_regularized(a::Number, tol=defaulttol(a))
inv_regularized(A::Matrix, tol=defaulttol(A); isposdef = false, kwargs...)</code></pre><p>Compute a smooth regularised inverse (L2 Tikhonov regularisation) of a number or square  matrix a.</p><ul><li><p>For numbers, this is given by <code>inv(hypot(a, tol))</code>.</p></li><li><p>For matrices, this is computed using the singular value decomposition and aplying   <code>inv_regularized</code> to the singular values. If <code>isposdef = true</code>, the singular value   decomposition is equivalent to the (Hermitian) eigenvalue decomposition of <code>A</code> and   the latter is used instead.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/common/regularinv.jl#L5-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.inv_safe" href="#MatrixAlgebraKit.inv_safe"><code>MatrixAlgebraKit.inv_safe</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">function inv_safe(a::Number, tol=defaulttol(a))</code></pre><p>Compute the inverse of a number <code>a</code>, but return zero if <code>a</code> is smaller than <code>tol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/common/safemethods.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.iszerotangent" href="#MatrixAlgebraKit.iszerotangent"><code>MatrixAlgebraKit.iszerotangent</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">iszerotangent(x)</code></pre><p>Return true if <code>x</code> is of a type that the different AD engines use to communicate a (co)tangent that is identically zero. By overloading this method, and writing pullback definitions in term of it, we will be able to hook into different AD ecosystems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/common/pullbacks.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.left_null" href="#MatrixAlgebraKit.left_null"><code>MatrixAlgebraKit.left_null</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">left_null(A; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -&gt; N
left_null!(A, [N]; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -&gt; N</code></pre><p>Compute an orthonormal basis <code>N</code> for the cokernel of the matrix <code>A</code> of size <code>(m, n)</code>, i.e. the nullspace of <code>adjoint(A)</code>, such that <code>adjoint(A)*N ≈ 0</code> and <code>N&#39;*N ≈ I</code>. The keyword argument <code>kind</code> can be used to specify the specific orthogonal decomposition that should be used to factor <code>A</code>, whereas <code>atol</code> and <code>rtol</code> can be used to control the precision in determining the rank of <code>A</code> via its singular values.</p><p>This is a high-level wrapper and will use one of the decompositions <code>qr!</code> or <code>svd!</code> to compute the orthogonal basis <code>N</code>, as controlled by the keyword arguments.</p><p>When <code>kind</code> is provided, its possible values are</p><ul><li><p><code>kind == :qrpos</code>: <code>N</code> is computed using the positive QR decomposition.   This requires <code>iszero(atol) &amp;&amp; iszero(rtol)</code> and <code>left_null!(A, [N], kind=:qrpos)</code> is equivalent to   <code>qr_null!(A, [N], alg)</code> with a default value <code>alg = select_algorithm(qr_compact!, A; positive=true)</code></p></li><li><p><code>kind == :qr</code>: <code>N</code> is computed using the (nonpositive) QR decomposition.   This requires <code>iszero(atol) &amp;&amp; iszero(rtol)</code> and <code>left_null!(A, [N], kind=:qr)</code> is equivalent to   <code>qr_null!(A, [N], alg)</code> with a default value <code>alg = select_algorithm(qr_compact!, A)</code></p></li><li><p><code>kind == :svd</code>: <code>N</code> is computed using the singular value decomposition and will contain    the left singular vectors corresponding to the singular values that   are smaller than <code>max(atol, rtol * σ₁)</code>, where <code>σ₁</code> is the largest singular value of <code>A</code>.</p></li></ul><p>When <code>kind</code> is not provided, the default value is <code>:qrpos</code> when <code>iszero(atol) &amp;&amp; iszero(rtol)</code> and <code>:svd</code> otherwise. Finally, finer control is obtained by providing an explicit algorithm using the <code>alg</code> keyword argument, which should be compatible with the chosen or default value of <code>kind</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>left_null!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>N</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.right_null"><code>right_null(!)</code></a>, <a href="#MatrixAlgebraKit.left_orth"><code>left_orth(!)</code></a>, <a href="#MatrixAlgebraKit.right_orth"><code>right_orth(!)</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/orthnull.jl#L133-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.left_orth" href="#MatrixAlgebraKit.left_orth"><code>MatrixAlgebraKit.left_orth</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">left_orth(A; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -&gt; V, C
left_orth!(A, [VC]; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -&gt; V, C</code></pre><p>Compute an orthonormal basis <code>V</code> for the image of the matrix <code>A</code> of size <code>(m, n)</code>, as well as a  matrix <code>C</code> (the corestriction) such that <code>A</code> factors as <code>A = V * C</code>. The keyword argument <code>kind</code> can be used to specify the specific orthogonal decomposition that should be used to factor <code>A</code>, whereas <code>atol</code> and <code>rtol</code> can be used to control the precision in determining the rank of <code>A</code> via its singular values.</p><p>This is a high-level wrapper and will use one of the decompositions <code>qr!</code>, <code>svd!</code>, and <code>left_polar!</code> to compute the orthogonal basis <code>V</code>, as controlled by the keyword arguments.</p><p>When <code>kind</code> is provided, its possible values are</p><ul><li><p><code>kind == :qrpos</code>: <code>V</code> and <code>C</code> are computed using the positive QR decomposition.   This requires <code>iszero(atol) &amp;&amp; iszero(rtol)</code> and <code>left_orth!(A, [VC])</code> is equivalent to   <code>qr_compact!(A, [VC], alg)</code> with a default value <code>alg = select_algorithm(qr_compact!, A; positive=true)</code></p></li><li><p><code>kind == :qr</code>: <code>V</code> and <code>C</code> are computed using the QR decomposition,   This requires <code>iszero(atol) &amp;&amp; iszero(rtol)</code> and <code>left_orth!(A, [VC])</code> is equivalent to   <code>qr_compact!(A, [VC], alg)</code> with a default value <code>alg = select_algorithm(qr_compact!, A)</code></p></li><li><p><code>kind == :polar</code>: <code>V</code> and <code>C</code> are computed using the polar decomposition,   This requires <code>iszero(atol) &amp;&amp; iszero(rtol)</code> and <code>left_orth!(A, [VC])</code> is equivalent to   <code>left_polar!(A, [VC], alg)</code> with a default value <code>alg = select_algorithm(left_polar!, A)</code></p></li><li><p><code>kind == :svd</code>: <code>V</code> and <code>C</code> are computed using the singular value decomposition <code>svd_trunc!</code>,   where <code>V</code> will contain the left singular vectors corresponding to the singular values that   are larger than <code>max(atol, rtol * σ₁)</code>, where <code>σ₁</code> is the largest singular value of <code>A</code>.   <code>C</code> is computed as the product of the singular values and the right singular vectors,   i.e. with <code>U, S, Vᴴ = svd_trunc!(A)</code>, we have <code>V = U</code> and <code>C = S * Vᴴ</code>.</p></li></ul><p>When <code>kind</code> is not provided, the default value is <code>:qrpos</code> when <code>iszero(atol) &amp;&amp; iszero(rtol)</code> and <code>:svd</code> otherwise. Finally, finer control is obtained by providing an explicit algorithm using the <code>alg</code> keyword argument, which should be compatible with the chosen or default value of <code>kind</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>left_orth!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>CV</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.right_orth"><code>right_orth(!)</code></a>, <a href="#MatrixAlgebraKit.left_orth"><code>left_orth(!)</code></a>, <a href="#MatrixAlgebraKit.right_orth"><code>right_orth(!)</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/orthnull.jl#L21-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.left_polar" href="#MatrixAlgebraKit.left_polar"><code>MatrixAlgebraKit.left_polar</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">left_polar(A; kwargs...) -&gt; W, P
left_polar(A, alg::AbstractAlgorithm) -&gt; W, P
left_polar!(A, [WP]; kwargs...) -&gt; W, P
left_polar!(A, [WP], alg::AbstractAlgorithm) -&gt; W, P</code></pre><p>Compute the full polar decomposition of the rectangular matrix <code>A</code> of size <code>(m, n)</code> with <code>m &gt;= n</code>, such that <code>A = W * P</code>. Here, <code>W</code> is an isometric matrix (orthonormal columns) of size <code>(m, n)</code>, whereas <code>P</code> is a positive (semi)definite matrix of size <code>(n, n)</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>left_polar!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>WP</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.right_polar"><code>right_polar(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/polar.jl#L12-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.left_polar!" href="#MatrixAlgebraKit.left_polar!"><code>MatrixAlgebraKit.left_polar!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">left_polar(A; kwargs...) -&gt; W, P
left_polar(A, alg::AbstractAlgorithm) -&gt; W, P
left_polar!(A, [WP]; kwargs...) -&gt; W, P
left_polar!(A, [WP], alg::AbstractAlgorithm) -&gt; W, P</code></pre><p>Compute the full polar decomposition of the rectangular matrix <code>A</code> of size <code>(m, n)</code> with <code>m &gt;= n</code>, such that <code>A = W * P</code>. Here, <code>W</code> is an isometric matrix (orthonormal columns) of size <code>(m, n)</code>, whereas <code>P</code> is a positive (semi)definite matrix of size <code>(n, n)</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>left_polar!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>WP</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.right_polar"><code>right_polar(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/polar.jl#L12-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.lq_compact" href="#MatrixAlgebraKit.lq_compact"><code>MatrixAlgebraKit.lq_compact</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lq_compact(A; kwargs...) -&gt; L, Q
lq_compact(A, alg::AbstractAlgorithm) -&gt; L, Q
lq_compact!(A, [LQ]; kwargs...) -&gt; L, Q
lq_compact!(A, [LQ], alg::AbstractAlgorithm) -&gt; L, Q</code></pre><p>Compute the compact LQ decomposition of the rectangular matrix <code>A</code> of size <code>(m,n)</code>, such that <code>A = L * Q</code> where the matrix <code>Q</code> of size <code>(min(m,n), n)</code> has orthogonal rows spanning the image of <code>A&#39;</code>, and the matrix <code>L</code> of size <code>(m, min(m,n))</code> is lower triangular.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>lq_compact!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>LQ</code> as output.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The compact QR decomposition is equivalent to the full LQ decomposition when <code>m &gt;= n</code>. Some algorithms may require <code>m &lt;= n</code>.</p></div></div><p>See also <a href="#MatrixAlgebraKit.lq_full"><code>lq_full(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/lq.jl#L22-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.lq_compact!" href="#MatrixAlgebraKit.lq_compact!"><code>MatrixAlgebraKit.lq_compact!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lq_compact(A; kwargs...) -&gt; L, Q
lq_compact(A, alg::AbstractAlgorithm) -&gt; L, Q
lq_compact!(A, [LQ]; kwargs...) -&gt; L, Q
lq_compact!(A, [LQ], alg::AbstractAlgorithm) -&gt; L, Q</code></pre><p>Compute the compact LQ decomposition of the rectangular matrix <code>A</code> of size <code>(m,n)</code>, such that <code>A = L * Q</code> where the matrix <code>Q</code> of size <code>(min(m,n), n)</code> has orthogonal rows spanning the image of <code>A&#39;</code>, and the matrix <code>L</code> of size <code>(m, min(m,n))</code> is lower triangular.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>lq_compact!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>LQ</code> as output.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The compact QR decomposition is equivalent to the full LQ decomposition when <code>m &gt;= n</code>. Some algorithms may require <code>m &lt;= n</code>.</p></div></div><p>See also <a href="#MatrixAlgebraKit.lq_full"><code>lq_full(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/lq.jl#L22-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.lq_full" href="#MatrixAlgebraKit.lq_full"><code>MatrixAlgebraKit.lq_full</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lq_full(A; kwargs...) -&gt; L, Q
lq_full(A, alg::AbstractAlgorithm) -&gt; L, Q
lq_full!(A, [LQ]; kwargs...) -&gt; L, Q
lq_full!(A, [LQ], alg::AbstractAlgorithm) -&gt; L, Q</code></pre><p>Compute the full LQ decomposition of the rectangular matrix <code>A</code>, such that <code>A = L * Q</code> where <code>Q</code> is a square unitary matrix with the same number of rows as <code>A</code> and <code>L</code> is a lower triangular matrix with the same size as <code>A</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>lq_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>LQ</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.lq_compact"><code>lq_compact(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/lq.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.lq_full!" href="#MatrixAlgebraKit.lq_full!"><code>MatrixAlgebraKit.lq_full!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lq_full(A; kwargs...) -&gt; L, Q
lq_full(A, alg::AbstractAlgorithm) -&gt; L, Q
lq_full!(A, [LQ]; kwargs...) -&gt; L, Q
lq_full!(A, [LQ], alg::AbstractAlgorithm) -&gt; L, Q</code></pre><p>Compute the full LQ decomposition of the rectangular matrix <code>A</code>, such that <code>A = L * Q</code> where <code>Q</code> is a square unitary matrix with the same number of rows as <code>A</code> and <code>L</code> is a lower triangular matrix with the same size as <code>A</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>lq_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>LQ</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.lq_compact"><code>lq_compact(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/lq.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.lq_null" href="#MatrixAlgebraKit.lq_null"><code>MatrixAlgebraKit.lq_null</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lq_null(A; kwargs...) -&gt; Nᴴ
lq_null(A, alg::AbstractAlgorithm) -&gt; Nᴴ
lq_null!(A, [Nᴴ]; kwargs...) -&gt; Nᴴ
lq_null!(A, [Nᴴ], alg::AbstractAlgorithm) -&gt; Nᴴ</code></pre><p>For a (m, n) matrix A, compute the matrix <code>Nᴴ</code> corresponding the final <code>n - min(m, n)</code> rows  oft the unitary <code>Q</code> factor in the full LQ decomposition of <code>A</code>, i.e. the rows that are not present in the <code>Q</code> factor of the compact LQ decomposition. The matrix <code>Nᴴ</code> is such that the isometric matrix <code>N = adjoint(Nᴴ)</code> contains an orthonormal basis for the kernel (null space) of <code>A</code> as its columns, i.e. <code>A * N = 0</code> or thus <code>A * adjoint(Nᴴ) = 0</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>lq_null!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>Nᴴ</code> argument as output.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The matrix <code>Nᴴ</code> is empty when <code>m &gt;= n</code>.</p></div></div><p>See also <a href="#MatrixAlgebraKit.lq_full"><code>qr_full(!)</code></a> and <a href="#MatrixAlgebraKit.lq_compact"><code>qr_compact(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/lq.jl#L45-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.lq_null!" href="#MatrixAlgebraKit.lq_null!"><code>MatrixAlgebraKit.lq_null!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lq_null(A; kwargs...) -&gt; Nᴴ
lq_null(A, alg::AbstractAlgorithm) -&gt; Nᴴ
lq_null!(A, [Nᴴ]; kwargs...) -&gt; Nᴴ
lq_null!(A, [Nᴴ], alg::AbstractAlgorithm) -&gt; Nᴴ</code></pre><p>For a (m, n) matrix A, compute the matrix <code>Nᴴ</code> corresponding the final <code>n - min(m, n)</code> rows  oft the unitary <code>Q</code> factor in the full LQ decomposition of <code>A</code>, i.e. the rows that are not present in the <code>Q</code> factor of the compact LQ decomposition. The matrix <code>Nᴴ</code> is such that the isometric matrix <code>N = adjoint(Nᴴ)</code> contains an orthonormal basis for the kernel (null space) of <code>A</code> as its columns, i.e. <code>A * N = 0</code> or thus <code>A * adjoint(Nᴴ) = 0</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>lq_null!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>Nᴴ</code> argument as output.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The matrix <code>Nᴴ</code> is empty when <code>m &gt;= n</code>.</p></div></div><p>See also <a href="#MatrixAlgebraKit.lq_full"><code>qr_full(!)</code></a> and <a href="#MatrixAlgebraKit.lq_compact"><code>qr_compact(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/lq.jl#L45-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.qr_compact" href="#MatrixAlgebraKit.qr_compact"><code>MatrixAlgebraKit.qr_compact</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qr_compact(A; kwargs...) -&gt; Q, R
qr_compact(A, alg::AbstractAlgorithm) -&gt; Q, R
qr_compact!(A, [QR]; kwargs...) -&gt; Q, R
qr_compact!(A, [QR], alg::AbstractAlgorithm) -&gt; Q, R</code></pre><p>Compute the compact QR decomposition of the rectangular matrix <code>A</code> of size <code>(m,n)</code>, such that <code>A = Q * R</code> where the isometric matrix <code>Q</code> of size <code>(m, min(m,n))</code> has orthogonal columns spanning the image of <code>A</code>, and the matrix <code>R</code> of size <code>(min(m,n), n)</code> is upper triangular.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>qr_compact!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>QR</code> as output.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The compact QR decomposition is equivalent to the full QR decomposition when <code>m &gt;= n</code>. Some algorithms may require <code>m &gt;= n</code>.</p></div></div><p>See also <a href="#MatrixAlgebraKit.qr_full"><code>qr_full(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/qr.jl#L22-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.qr_compact!" href="#MatrixAlgebraKit.qr_compact!"><code>MatrixAlgebraKit.qr_compact!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qr_compact(A; kwargs...) -&gt; Q, R
qr_compact(A, alg::AbstractAlgorithm) -&gt; Q, R
qr_compact!(A, [QR]; kwargs...) -&gt; Q, R
qr_compact!(A, [QR], alg::AbstractAlgorithm) -&gt; Q, R</code></pre><p>Compute the compact QR decomposition of the rectangular matrix <code>A</code> of size <code>(m,n)</code>, such that <code>A = Q * R</code> where the isometric matrix <code>Q</code> of size <code>(m, min(m,n))</code> has orthogonal columns spanning the image of <code>A</code>, and the matrix <code>R</code> of size <code>(min(m,n), n)</code> is upper triangular.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>qr_compact!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>QR</code> as output.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The compact QR decomposition is equivalent to the full QR decomposition when <code>m &gt;= n</code>. Some algorithms may require <code>m &gt;= n</code>.</p></div></div><p>See also <a href="#MatrixAlgebraKit.qr_full"><code>qr_full(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/qr.jl#L22-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.qr_full" href="#MatrixAlgebraKit.qr_full"><code>MatrixAlgebraKit.qr_full</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qr_full(A; kwargs...) -&gt; Q, R
qr_full(A, alg::AbstractAlgorithm) -&gt; Q, R
qr_full!(A, [QR]; kwargs...) -&gt; Q, R
qr_full!(A, [QR], alg::AbstractAlgorithm) -&gt; Q, R</code></pre><p>Compute the full QR decomposition of the rectangular matrix <code>A</code>, such that <code>A = Q * R</code> where <code>Q</code> is a square unitary matrix with the same number of rows as <code>A</code> and <code>R</code> is an upper triangular matrix with the same size as <code>A</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>qr_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>QR</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.qr_compact"><code>qr_compact(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/qr.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.qr_full!" href="#MatrixAlgebraKit.qr_full!"><code>MatrixAlgebraKit.qr_full!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qr_full(A; kwargs...) -&gt; Q, R
qr_full(A, alg::AbstractAlgorithm) -&gt; Q, R
qr_full!(A, [QR]; kwargs...) -&gt; Q, R
qr_full!(A, [QR], alg::AbstractAlgorithm) -&gt; Q, R</code></pre><p>Compute the full QR decomposition of the rectangular matrix <code>A</code>, such that <code>A = Q * R</code> where <code>Q</code> is a square unitary matrix with the same number of rows as <code>A</code> and <code>R</code> is an upper triangular matrix with the same size as <code>A</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>qr_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>QR</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.qr_compact"><code>qr_compact(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/qr.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.qr_null" href="#MatrixAlgebraKit.qr_null"><code>MatrixAlgebraKit.qr_null</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qr_null(A; kwargs...) -&gt; N
qr_null(A, alg::AbstractAlgorithm) -&gt; N
qr_null!(A, [N]; kwargs...) -&gt; N
qr_null!(A, [N], alg::AbstractAlgorithm) -&gt; N</code></pre><p>For a (m, n) matrix A, compute the matrix <code>N</code> corresponding the final <code>m - min(m, n)</code> columns  of the unitary <code>Q</code> factor in the full QR decomposition of <code>A</code>, i.e. the columns that are not present in the <code>Q</code> factor of the compact QR decomposition. The isometric matrix <code>N</code> contains an orthonormal basis for the cokernel of <code>A</code> as its columns, i.e. <code>adjoint(A) * N = 0</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>qr_null!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>N</code> argument as output.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The matrix <code>N</code> is empty when <code>m &lt;= n</code>.</p></div></div><p>See also <a href="#MatrixAlgebraKit.lq_full"><code>lq_full(!)</code></a> and <a href="#MatrixAlgebraKit.lq_compact"><code>lq_compact(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/qr.jl#L46-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.qr_null!" href="#MatrixAlgebraKit.qr_null!"><code>MatrixAlgebraKit.qr_null!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">qr_null(A; kwargs...) -&gt; N
qr_null(A, alg::AbstractAlgorithm) -&gt; N
qr_null!(A, [N]; kwargs...) -&gt; N
qr_null!(A, [N], alg::AbstractAlgorithm) -&gt; N</code></pre><p>For a (m, n) matrix A, compute the matrix <code>N</code> corresponding the final <code>m - min(m, n)</code> columns  of the unitary <code>Q</code> factor in the full QR decomposition of <code>A</code>, i.e. the columns that are not present in the <code>Q</code> factor of the compact QR decomposition. The isometric matrix <code>N</code> contains an orthonormal basis for the cokernel of <code>A</code> as its columns, i.e. <code>adjoint(A) * N = 0</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>qr_null!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>N</code> argument as output.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The matrix <code>N</code> is empty when <code>m &lt;= n</code>.</p></div></div><p>See also <a href="#MatrixAlgebraKit.lq_full"><code>lq_full(!)</code></a> and <a href="#MatrixAlgebraKit.lq_compact"><code>lq_compact(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/qr.jl#L46-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.right_null" href="#MatrixAlgebraKit.right_null"><code>MatrixAlgebraKit.right_null</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">right_null(A; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -&gt; Nᴴ
right_null!(A, [Nᴴ]; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -&gt; Nᴴ</code></pre><p>Compute an orthonormal basis <code>N = adjoint(Nᴴ)</code> for the kernel or nullspace of the matrix <code>A</code> of size <code>(m, n)</code>, such that <code>A*adjoint(Nᴴ) ≈ 0</code> and <code>Nᴴ*adjoint(Nᴴ) ≈ I</code>. The keyword argument <code>kind</code> can be used to specify the specific orthogonal decomposition that should be used to factor <code>A</code>, whereas <code>atol</code> and <code>rtol</code> can be used to control the precision in determining the rank of <code>A</code> via its singular values.</p><p>This is a high-level wrapper and will use one of the decompositions <code>lq!</code> or <code>svd!</code> to compute the orthogonal basis <code>Nᴴ</code>, as controlled by the keyword arguments.</p><p>When <code>kind</code> is provided, its possible values are</p><ul><li><p><code>kind == :lqpos</code>: <code>Nᴴ</code> is computed using the positive LQ decomposition.   This requires <code>iszero(atol) &amp;&amp; iszero(rtol)</code> and <code>right_null!(A, [Nᴴ], kind=:lqpos)</code> is equivalent to   <code>lq_null!(A, [Nᴴ], alg)</code> with a default value <code>alg = select_algorithm(lq_compact!, A; positive=true)</code></p></li><li><p><code>kind == :lq</code>: <code>Nᴴ</code> is computed using the (nonpositive) LQ decomposition.   This requires <code>iszero(atol) &amp;&amp; iszero(rtol)</code> and <code>right_null!(A, [Nᴴ], kind=:lq)</code> is equivalent to   <code>lq_null!(A, [Nᴴ], alg)</code> with a default value <code>alg = select_algorithm(lq_compact!, A)</code></p></li><li><p><code>kind == :svd</code>: <code>N</code> is computed using the singular value decomposition and will contain    the left singular vectors corresponding to the singular values that   are smaller than <code>max(atol, rtol * σ₁)</code>, where <code>σ₁</code> is the largest singular value of <code>A</code>.</p></li></ul><p>When <code>kind</code> is not provided, the default value is <code>:lqpos</code> when <code>iszero(atol) &amp;&amp; iszero(rtol)</code> and <code>:svd</code> otherwise. Finally, finer control is obtained by providing an explicit algorithm using the <code>alg</code> keyword argument, which should be compatible with the chosen or default value of <code>kind</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>right_null!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>Nᴴ</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.left_null"><code>left_null(!)</code></a>, <a href="#MatrixAlgebraKit.left_orth"><code>left_orth(!)</code></a>, <a href="#MatrixAlgebraKit.right_orth"><code>right_orth(!)</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/orthnull.jl#L181-L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.right_orth" href="#MatrixAlgebraKit.right_orth"><code>MatrixAlgebraKit.right_orth</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">right_orth(A; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -&gt; C, Vᴴ
right_orth!(A, [CVᴴ]; [kind::Symbol, atol::Real=0, rtol::Real=0, alg]) -&gt; C, Vᴴ</code></pre><p>Compute an orthonormal basis <code>V = adjoint(Vᴴ)</code> for the coimage of the matrix <code>A</code>, i.e. for the image of <code>adjoint(A)</code>, as well as a matrix <code>C</code> such that <code>A = C * Vᴴ</code>. The keyword argument <code>kind</code> can be used to specify the specific orthogonal decomposition that should be used to factor <code>A</code>, whereas <code>atol</code> and <code>rtol</code> can be used to control the precision in determining the rank of <code>A</code> via its singular values.</p><p>This is a high-level wrapper and will use call one of the decompositions <code>qr!</code>, <code>svd!</code>, and <code>left_polar!</code> to compute the orthogonal basis <code>V</code>, as controlled by the keyword arguments.</p><p>When <code>kind</code> is provided, its possible values are</p><ul><li><p><code>kind == :lqpos</code>: <code>C</code> and <code>Vᴴ</code> are computed using the positive QR decomposition.   This requires <code>iszero(atol) &amp;&amp; iszero(rtol)</code> and <code>right_orth!(A, [CVᴴ])</code> is equivalent to   <code>lq_compact!(A, [CVᴴ], alg)</code> with a default value <code>alg = select_algorithm(lq_compact!, A; positive=true)</code></p></li><li><p><code>kind == :lq</code>: <code>C</code> and <code>Vᴴ</code> are computed using the QR decomposition,   This requires <code>iszero(atol) &amp;&amp; iszero(rtol)</code> and <code>right_orth!(A, [CVᴴ])</code> is equivalent to   <code>lq_compact!(A, [CVᴴ], alg)</code> with a default value <code>alg = select_algorithm(lq_compact!, A))</code></p></li><li><p><code>kind == :polar</code>: <code>C</code> and <code>Vᴴ</code> are computed using the polar decomposition,   This requires <code>iszero(atol) &amp;&amp; iszero(rtol)</code> and <code>right_orth!(A, [CVᴴ])</code> is equivalent to   <code>right_polar!(A, [CVᴴ], alg)</code> with a default value <code>alg = select_algorithm(right_polar!, A))</code></p></li><li><p><code>kind == :svd</code>: <code>C</code> and <code>Vᴴ</code> are computed using the singular value decomposition <code>svd_trunc!</code>,   where <code>V = adjoint(Vᴴ)</code> will contain the right singular vectors corresponding to the singular   values that are larger than <code>max(atol, rtol * σ₁)</code>, where <code>σ₁</code> is the largest singular value of <code>A</code>.   <code>C</code> is computed as the product of the singular values and the right singular vectors,   i.e. with <code>U, S, Vᴴ = svd_trunc!(A)</code>, we have <code>C = rmul!(U, S)</code> and <code>Vᴴ = Vᴴ</code>.</p></li></ul><p>When <code>kind</code> is not provided, the default value is <code>:lqpos</code> when <code>iszero(atol) &amp;&amp; iszero(rtol)</code> and <code>:svd</code> otherwise. Finally, finer control is obtained by providing an explicit algorithm using the <code>alg</code> keyword argument, which should be compatible with the chosen or default value of <code>kind</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>right_orth!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>CVᴴ</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.left_orth"><code>left_orth(!)</code></a>, <a href="#MatrixAlgebraKit.left_orth"><code>left_orth(!)</code></a>, <a href="#MatrixAlgebraKit.right_orth"><code>right_orth(!)</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/orthnull.jl#L76-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.right_polar" href="#MatrixAlgebraKit.right_polar"><code>MatrixAlgebraKit.right_polar</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">right_polar(A; kwargs...) -&gt; P, Wᴴ
right_polar(A, alg::AbstractAlgorithm) -&gt; P, Wᴴ
right_polar!(A, [PWᴴ]; kwargs...) -&gt; P, Wᴴ
right_polar!(A, [PWᴴ], alg::AbstractAlgorithm) -&gt; P, Wᴴ</code></pre><p>Compute the full polar decomposition of the rectangular matrix <code>A</code> of size <code>(m, n)</code> with <code>n &gt;= m</code>, such that <code>A = P * Wᴴ</code>. Here, <code>P</code> is a positive (semi)definite matrix of size <code>(m, m)</code>, whereas <code>Wᴴ</code> is a matrix with orthonormal rows (its adjoint is isometric) of size <code>(n, m)</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>right_polar!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>WP</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.left_polar"><code>left_polar(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/polar.jl#L31-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.right_polar!" href="#MatrixAlgebraKit.right_polar!"><code>MatrixAlgebraKit.right_polar!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">right_polar(A; kwargs...) -&gt; P, Wᴴ
right_polar(A, alg::AbstractAlgorithm) -&gt; P, Wᴴ
right_polar!(A, [PWᴴ]; kwargs...) -&gt; P, Wᴴ
right_polar!(A, [PWᴴ], alg::AbstractAlgorithm) -&gt; P, Wᴴ</code></pre><p>Compute the full polar decomposition of the rectangular matrix <code>A</code> of size <code>(m, n)</code> with <code>n &gt;= m</code>, such that <code>A = P * Wᴴ</code>. Here, <code>P</code> is a positive (semi)definite matrix of size <code>(m, m)</code>, whereas <code>Wᴴ</code> is a matrix with orthonormal rows (its adjoint is isometric) of size <code>(n, m)</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>right_polar!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>WP</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.left_polar"><code>left_polar(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/polar.jl#L31-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.safesign-Tuple{Real}" href="#MatrixAlgebraKit.safesign-Tuple{Real}"><code>MatrixAlgebraKit.safesign</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">safesign(s::Number)</code></pre><p>Compute the sign of a number <code>s</code>, but return <code>+1</code> if <code>s</code> is zero so that the result is always a number with modulus 1, i.e. an element of the unitary group U(1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/common/safemethods.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.schur_full" href="#MatrixAlgebraKit.schur_full"><code>MatrixAlgebraKit.schur_full</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">schur_full(A; kwargs...) -&gt; T, Z, vals
schur_full(A, alg::AbstractAlgorithm) -&gt; T, Z, vals
schur_full!(A, [TZv]; kwargs...) -&gt; T, Z, vals
schur_full!(A, [TZv], alg::AbstractAlgorithm) -&gt; T, Z, vals</code></pre><p>Compute the full Schur decomposition of the square matrix <code>A</code>, such that <code>A * Z = Z * T</code>, where the orthogonal or unitary matrix <code>Z</code> contains the Schur vectors and the square matrix <code>T</code> is upper triangular (in the complex case) or quasi-upper triangular (in the real case). The list <code>vals</code> contains the (complex-valued) eigenvalues of <code>A</code>, as extracted from the (quasi-)diagonal of <code>T</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>schur_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>TZv</code> as output.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/schur.jl#L13-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.schur_full!" href="#MatrixAlgebraKit.schur_full!"><code>MatrixAlgebraKit.schur_full!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">schur_full(A; kwargs...) -&gt; T, Z, vals
schur_full(A, alg::AbstractAlgorithm) -&gt; T, Z, vals
schur_full!(A, [TZv]; kwargs...) -&gt; T, Z, vals
schur_full!(A, [TZv], alg::AbstractAlgorithm) -&gt; T, Z, vals</code></pre><p>Compute the full Schur decomposition of the square matrix <code>A</code>, such that <code>A * Z = Z * T</code>, where the orthogonal or unitary matrix <code>Z</code> contains the Schur vectors and the square matrix <code>T</code> is upper triangular (in the complex case) or quasi-upper triangular (in the real case). The list <code>vals</code> contains the (complex-valued) eigenvalues of <code>A</code>, as extracted from the (quasi-)diagonal of <code>T</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>schur_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>TZv</code> as output.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/schur.jl#L13-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.schur_vals" href="#MatrixAlgebraKit.schur_vals"><code>MatrixAlgebraKit.schur_vals</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">schur_vals(A; kwargs...) -&gt; vals
schur_vals(A, alg::AbstractAlgorithm) -&gt; vals
schur_vals!(A, [vals]; kwargs...) -&gt; vals
schur_vals!(A, [vals], alg::AbstractAlgorithm) -&gt; vals</code></pre><p>Compute the list of eigenvalues of <code>A</code> by computing the Schur decomposition of <code>A</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>schur_vals!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>vals</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.eig_full"><code>eig_full(!)</code></a> and <a href="#MatrixAlgebraKit.eig_trunc"><code>eig_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/schur.jl#L33-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.schur_vals!" href="#MatrixAlgebraKit.schur_vals!"><code>MatrixAlgebraKit.schur_vals!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">schur_vals(A; kwargs...) -&gt; vals
schur_vals(A, alg::AbstractAlgorithm) -&gt; vals
schur_vals!(A, [vals]; kwargs...) -&gt; vals
schur_vals!(A, [vals], alg::AbstractAlgorithm) -&gt; vals</code></pre><p>Compute the list of eigenvalues of <code>A</code> by computing the Schur decomposition of <code>A</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>schur_vals!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>vals</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.eig_full"><code>eig_full(!)</code></a> and <a href="#MatrixAlgebraKit.eig_trunc"><code>eig_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/schur.jl#L33-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.select_algorithm" href="#MatrixAlgebraKit.select_algorithm"><code>MatrixAlgebraKit.select_algorithm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">select_algorithm(f, A; kwargs...)</code></pre><p>Given some keyword arguments and an input <code>A</code>, decide on an algrithm to use for implementing the function <code>f</code> on inputs of type <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/algorithms.jl#L56-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.svd_compact" href="#MatrixAlgebraKit.svd_compact"><code>MatrixAlgebraKit.svd_compact</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">svd_compact(A; kwargs...) -&gt; U, S, Vᴴ
svd_compact(A, alg::AbstractAlgorithm) -&gt; U, S, Vᴴ
svd_compact!(A, [USVᴴ]; kwargs...) -&gt; U, S, Vᴴ
svd_compact!(A, [USVᴴ], alg::AbstractAlgorithm) -&gt; U, S, Vᴴ</code></pre><p>Compute the compact singular value decomposition (SVD) of the rectangular matrix <code>A</code> of size <code>(m, n)</code>, such that <code>A = U * S * Vᴴ</code>. Here, <code>U</code> is an isometric matrix (orthonormal columns) of size <code>(m, k)</code>, whereas  <code>Vᴴ</code> is a matrix of size <code>(k, n)</code> with orthonormal rows and <code>S</code> is a square diagonal matrix of size <code>(k, k)</code>, with <code>k = min(m, n)</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>svd_compact!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>USVᴴ</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.svd_full"><code>svd_full(!)</code></a>, <a href="#MatrixAlgebraKit.svd_vals"><code>svd_vals(!)</code></a> and <a href="#MatrixAlgebraKit.svd_trunc"><code>svd_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/svd.jl#L33-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.svd_compact!" href="#MatrixAlgebraKit.svd_compact!"><code>MatrixAlgebraKit.svd_compact!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">svd_compact(A; kwargs...) -&gt; U, S, Vᴴ
svd_compact(A, alg::AbstractAlgorithm) -&gt; U, S, Vᴴ
svd_compact!(A, [USVᴴ]; kwargs...) -&gt; U, S, Vᴴ
svd_compact!(A, [USVᴴ], alg::AbstractAlgorithm) -&gt; U, S, Vᴴ</code></pre><p>Compute the compact singular value decomposition (SVD) of the rectangular matrix <code>A</code> of size <code>(m, n)</code>, such that <code>A = U * S * Vᴴ</code>. Here, <code>U</code> is an isometric matrix (orthonormal columns) of size <code>(m, k)</code>, whereas  <code>Vᴴ</code> is a matrix of size <code>(k, n)</code> with orthonormal rows and <code>S</code> is a square diagonal matrix of size <code>(k, k)</code>, with <code>k = min(m, n)</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>svd_compact!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>USVᴴ</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.svd_full"><code>svd_full(!)</code></a>, <a href="#MatrixAlgebraKit.svd_vals"><code>svd_vals(!)</code></a> and <a href="#MatrixAlgebraKit.svd_trunc"><code>svd_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/svd.jl#L33-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.svd_full" href="#MatrixAlgebraKit.svd_full"><code>MatrixAlgebraKit.svd_full</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">svd_full(A; kwargs...) -&gt; U, S, Vᴴ
svd_full(A, alg::AbstractAlgorithm) -&gt; U, S, Vᴴ
svd_full!(A, [USVᴴ]; kwargs...) -&gt; U, S, Vᴴ
svd_full!(A, [USVᴴ], alg::AbstractAlgorithm) -&gt; U, S, Vᴴ</code></pre><p>Compute the full singular value decomposition (SVD) of the rectangular matrix <code>A</code> of size <code>(m, n)</code>, such that <code>A = U * S * Vᴴ</code>. Here, <code>U</code> and <code>Vᴴ</code> are unitary matrices of size <code>(m, m)</code> and <code>(n, n)</code> respectively, and <code>S</code> is a diagonal matrix of size <code>(m, n)</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>svd_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>USVᴴ</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.svd_compact"><code>svd_compact(!)</code></a>, <a href="#MatrixAlgebraKit.svd_vals"><code>svd_vals(!)</code></a> and <a href="#MatrixAlgebraKit.svd_trunc"><code>svd_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/svd.jl#L13-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.svd_full!" href="#MatrixAlgebraKit.svd_full!"><code>MatrixAlgebraKit.svd_full!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">svd_full(A; kwargs...) -&gt; U, S, Vᴴ
svd_full(A, alg::AbstractAlgorithm) -&gt; U, S, Vᴴ
svd_full!(A, [USVᴴ]; kwargs...) -&gt; U, S, Vᴴ
svd_full!(A, [USVᴴ], alg::AbstractAlgorithm) -&gt; U, S, Vᴴ</code></pre><p>Compute the full singular value decomposition (SVD) of the rectangular matrix <code>A</code> of size <code>(m, n)</code>, such that <code>A = U * S * Vᴴ</code>. Here, <code>U</code> and <code>Vᴴ</code> are unitary matrices of size <code>(m, m)</code> and <code>(n, n)</code> respectively, and <code>S</code> is a diagonal matrix of size <code>(m, n)</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>svd_full!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>USVᴴ</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.svd_compact"><code>svd_compact(!)</code></a>, <a href="#MatrixAlgebraKit.svd_vals"><code>svd_vals(!)</code></a> and <a href="#MatrixAlgebraKit.svd_trunc"><code>svd_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/svd.jl#L13-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.svd_trunc" href="#MatrixAlgebraKit.svd_trunc"><code>MatrixAlgebraKit.svd_trunc</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">svd_trunc(A; kwargs...) -&gt; U, S, Vᴴ
svd_trunc(A, alg::AbstractAlgorithm) -&gt; U, S, Vᴴ
svd_trunc!(A, [USVᴴ]; kwargs...) -&gt; U, S, Vᴴ
svd_trunc!(A, [USVᴴ], alg::AbstractAlgorithm) -&gt; U, S, Vᴴ</code></pre><p>Compute a partial or truncated singular value decomposition (SVD) of <code>A</code>, such that <code>A * (Vᴴ)&#39; =  U * S</code>. Here, <code>U</code> is an isometric matrix (orthonormal columns) of size <code>(m, k)</code>, whereas  <code>Vᴴ</code> is a matrix of size <code>(k, n)</code> with orthonormal rows and <code>S</code> is a square diagonal matrix of size <code>(k, k)</code>, with <code>k</code> is set by the truncation strategy.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>svd_trunc!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>USVᴴ</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.svd_full"><code>svd_full(!)</code></a>, <a href="#MatrixAlgebraKit.svd_compact"><code>svd_compact(!)</code></a> and <a href="#MatrixAlgebraKit.svd_vals"><code>svd_vals(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/svd.jl#L55-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.svd_trunc!" href="#MatrixAlgebraKit.svd_trunc!"><code>MatrixAlgebraKit.svd_trunc!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">svd_trunc(A; kwargs...) -&gt; U, S, Vᴴ
svd_trunc(A, alg::AbstractAlgorithm) -&gt; U, S, Vᴴ
svd_trunc!(A, [USVᴴ]; kwargs...) -&gt; U, S, Vᴴ
svd_trunc!(A, [USVᴴ], alg::AbstractAlgorithm) -&gt; U, S, Vᴴ</code></pre><p>Compute a partial or truncated singular value decomposition (SVD) of <code>A</code>, such that <code>A * (Vᴴ)&#39; =  U * S</code>. Here, <code>U</code> is an isometric matrix (orthonormal columns) of size <code>(m, k)</code>, whereas  <code>Vᴴ</code> is a matrix of size <code>(k, n)</code> with orthonormal rows and <code>S</code> is a square diagonal matrix of size <code>(k, k)</code>, with <code>k</code> is set by the truncation strategy.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The bang method <code>svd_trunc!</code> optionally accepts the output structure and possibly destroys the input matrix <code>A</code>. Always use the return value of the function as it may not always be possible to use the provided <code>USVᴴ</code> as output.</p></div></div><p>See also <a href="#MatrixAlgebraKit.svd_full"><code>svd_full(!)</code></a>, <a href="#MatrixAlgebraKit.svd_compact"><code>svd_compact(!)</code></a> and <a href="#MatrixAlgebraKit.svd_vals"><code>svd_vals(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/svd.jl#L55-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.svd_vals" href="#MatrixAlgebraKit.svd_vals"><code>MatrixAlgebraKit.svd_vals</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">svd_vals(A; kwargs...) -&gt; S
svd_vals(A, alg::AbstractAlgorithm) -&gt; S
svd_vals!(A, [S]; kwargs...) -&gt; S
svd_vals!(A, [S], alg::AbstractAlgorithm) -&gt; S</code></pre><p>Compute the vector of singular values of <code>A</code>, such that for an M×N matrix <code>A</code>, <code>S</code> is a vector of size <code>K = min(M, N)</code>, the number of kept singular values.</p><p>See also <a href="#MatrixAlgebraKit.svd_full"><code>svd_full(!)</code></a>, <a href="#MatrixAlgebraKit.svd_compact"><code>svd_compact(!)</code></a> and <a href="#MatrixAlgebraKit.svd_trunc"><code>svd_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/svd.jl#L77-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.svd_vals!" href="#MatrixAlgebraKit.svd_vals!"><code>MatrixAlgebraKit.svd_vals!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">svd_vals(A; kwargs...) -&gt; S
svd_vals(A, alg::AbstractAlgorithm) -&gt; S
svd_vals!(A, [S]; kwargs...) -&gt; S
svd_vals!(A, [S], alg::AbstractAlgorithm) -&gt; S</code></pre><p>Compute the vector of singular values of <code>A</code>, such that for an M×N matrix <code>A</code>, <code>S</code> is a vector of size <code>K = min(M, N)</code>, the number of kept singular values.</p><p>See also <a href="#MatrixAlgebraKit.svd_full"><code>svd_full(!)</code></a>, <a href="#MatrixAlgebraKit.svd_compact"><code>svd_compact(!)</code></a> and <a href="#MatrixAlgebraKit.svd_trunc"><code>svd_trunc(!)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/interface/svd.jl#L77-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.truncabove-Tuple{Any}" href="#MatrixAlgebraKit.truncabove-Tuple{Any}"><code>MatrixAlgebraKit.truncabove</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">truncabove(atol::Real)</code></pre><p>Truncation strategy to discard the values that are larger than <code>atol</code> in absolute value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/implementations/truncation.jl#L78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.truncate!" href="#MatrixAlgebraKit.truncate!"><code>MatrixAlgebraKit.truncate!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">truncate!(f, out, strategy::TruncationStrategy)</code></pre><p>Generic interface for post-truncating a decomposition, specified in <code>out</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/implementations/truncation.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.truncrank" href="#MatrixAlgebraKit.truncrank"><code>MatrixAlgebraKit.truncrank</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">truncrank(howmany::Int, by=abs, rev=true)</code></pre><p>Truncation strategy to keep the first <code>howmany</code> values when sorted according to <code>by</code> or the last <code>howmany</code> if <code>rev</code> is true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/implementations/truncation.jl#L64-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.trunctol-Tuple{Any}" href="#MatrixAlgebraKit.trunctol-Tuple{Any}"><code>MatrixAlgebraKit.trunctol</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trunctol(atol::Real)</code></pre><p>Truncation strategy to discard the values that are smaller than <code>atol</code> in absolute value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/implementations/truncation.jl#L71-L75">source</a></section></article><h2 id="Other"><a class="docs-heading-anchor" href="#Other">Other</a><a id="Other-1"></a><a class="docs-heading-anchor-permalink" href="#Other" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.@algdef-Tuple{Any}" href="#MatrixAlgebraKit.@algdef-Tuple{Any}"><code>MatrixAlgebraKit.@algdef</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@algdef AlgorithmName</code></pre><p>Convenience macro to define an algorithm <code>AlgorithmName</code> that accepts generic keywords. This defines an exported alias for <a href="#MatrixAlgebraKit.Algorithm"><code>Algorithm{:AlgorithmName}</code></a> along with some utility methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/algorithms.jl#L85-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixAlgebraKit.@functiondef-Tuple{Any}" href="#MatrixAlgebraKit.@functiondef-Tuple{Any}"><code>MatrixAlgebraKit.@functiondef</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@functiondef f</code></pre><p>Convenience macro to define the boilerplate code that dispatches between several versions of <code>f</code> and <code>f!</code>. By default, this enables the following signatures to be defined in terms of the final <code>f!(A, out, alg::Algorithm)</code>.</p><pre><code class="language-julia hljs">    f(A; kwargs...)
    f(A, alg::Algorithm)
    f!(A, [out]; kwargs...)
    f!(A, alg::Algorithm)</code></pre><p>See also <a href="#MatrixAlgebraKit.copy_input"><code>copy_input</code></a>, <a href="#MatrixAlgebraKit.select_algorithm"><code>select_algorithm</code></a> and <a href="#MatrixAlgebraKit.initialize_output"><code>initialize_output</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumKitHub/MatrixAlgebraKit.jl/blob/3bee5cde2972297613fcd863946c0ec547d885ae/src/algorithms.jl#L108-L123">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../dev_interface/">« Developer Interface</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Monday 10 March 2025 22:20">Monday 10 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
